<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>缓存击穿</title>
      <link href="/2023/11/21/redis%E7%AC%94%E8%AE%B0/%E4%B8%AA%E4%BA%BA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%BC%93%E5%AD%98%E5%87%BB%E7%A9%BF/"/>
      <url>/2023/11/21/redis%E7%AC%94%E8%AE%B0/%E4%B8%AA%E4%BA%BA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%BC%93%E5%AD%98%E5%87%BB%E7%A9%BF/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/># 缓存击穿<p><img src="https://gitee.com/Button_mkns/picgo/raw/master/img/%E7%BC%93%E5%AD%98%E5%87%BB%E7%A9%BF%E7%9A%84%E4%B8%A4%E7%A7%8D%E8%A7%A3%E5%86%B3%E6%96%B9%E5%BC%8F" alt="缓存击穿的两种解决方式"></p><p><strong>优缺点分析</strong></p><p><img src="https://gitee.com/Button_mkns/picgo/raw/master/img/%E4%BC%98%E7%BC%BA%E7%82%B9%E5%88%86%E6%9E%90" alt="优缺点分析"></p><h2 id="案例一：-基于互斥锁方式解决缓存击穿问题"><a href="#案例一：-基于互斥锁方式解决缓存击穿问题" class="headerlink" title="案例一： 基于互斥锁方式解决缓存击穿问题"></a>案例一： 基于互斥锁方式解决缓存击穿问题</h2><blockquote><p>需求: 修改根据id查询商铺的业务，基于互斥锁方式来解决缓存击穿问题</p></blockquote><p>首先编写锁的创建和释放方法</p><p><img src="https://gitee.com/Button_mkns/picgo/raw/master/img/image-20231121171740749.png" alt="image-20231121171740749"></p><p>案例 代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">public</span> Result <span class="title function_">queryById</span><span class="params">(Long id)</span> &#123;</span><br><span class="line">        <span class="comment">//缓存 穿透</span></span><br><span class="line"><span class="comment">//        Shop shop = queryWithPassThrough(id);</span></span><br><span class="line">        <span class="type">Shop</span> <span class="variable">shop</span> <span class="operator">=</span> queryWithMutex(id);</span><br><span class="line">        <span class="comment">//互斥锁解决缓存击穿</span></span><br><span class="line">        <span class="keyword">if</span> (shop == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> Result.fail(<span class="string">&quot;店铺不存在!!!!!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Result.ok(shop);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Shop <span class="title function_">queryWithMutex</span><span class="params">(Long id)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> RedisConstants.CACHE_SHOP_KEY + id;</span><br><span class="line">        <span class="comment">//1.从redis查询商铺缓存</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">shopJson</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().get(key);</span><br><span class="line">        <span class="comment">//2.判断是否存在</span></span><br><span class="line">        <span class="keyword">if</span> (StrUtil.isNotBlank(shopJson)) &#123;</span><br><span class="line">            <span class="comment">//3.存在,直接返回</span></span><br><span class="line">            <span class="keyword">return</span> JSONUtil.toBean(shopJson, Shop.class);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 判断命中的是否是空值</span></span><br><span class="line">        <span class="keyword">if</span> (shopJson != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 返回错误信息</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//4.实现缓存重建</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">lockKey</span> <span class="operator">=</span> LOCK_SHOP_KEY + id;</span><br><span class="line">        <span class="type">Shop</span> <span class="variable">shop</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//4.1.获取互斥锁</span></span><br><span class="line">            <span class="type">boolean</span> <span class="variable">tryLock</span> <span class="operator">=</span> tryLock(lockKey);</span><br><span class="line">            <span class="comment">//4.2.判断是否获取成功</span></span><br><span class="line">            <span class="keyword">if</span> (!tryLock) &#123;</span><br><span class="line">                <span class="comment">//4.3.失败，则休眠并重试</span></span><br><span class="line">                Thread.sleep(<span class="number">50</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//4.4.成功，根据id查询数据库</span></span><br><span class="line">            shop = getById(id);</span><br><span class="line">            <span class="comment">//5.不存在，根据id查询数据库</span></span><br><span class="line">            <span class="keyword">if</span> (shop == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">//将空值写入redis</span></span><br><span class="line">                stringRedisTemplate.opsForValue().set(key, <span class="string">&quot;&quot;</span>, CACHE_NULL_TTL, TimeUnit.MINUTES);</span><br><span class="line">                <span class="comment">//5.不存在，返回错误</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//6.存在，写入redis</span></span><br><span class="line">            stringRedisTemplate.opsForValue().set(key, JSONUtil.toJsonStr(shop), CACHE_SHOP_TTL, TimeUnit.MINUTES);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">//7.释放互斥锁</span></span><br><span class="line">            onLock(lockKey);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//8.返回</span></span><br><span class="line">        <span class="keyword">return</span> shop;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="案例二：基于逻辑过期方式解决缓存击穿问题"><a href="#案例二：基于逻辑过期方式解决缓存击穿问题" class="headerlink" title="案例二：基于逻辑过期方式解决缓存击穿问题"></a>案例二：基于逻辑过期方式解决缓存击穿问题</h2><blockquote><p>需求:修改根据id查询商铺的业务，基于逻辑过期方式来解决缓存击穿问题</p></blockquote><p><strong>业务流程</strong></p><p><img src="https://gitee.com/Button_mkns/picgo/raw/master/img/image-20231122092158767.png" alt="image-20231122092158767"></p><p>案例代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建线程池</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">ExecutorService</span> <span class="variable">CACHE_REBUILD_EXECUTOR</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   <span class="comment">//通过逻辑过期解决缓存击穿问题</span></span><br><span class="line">   <span class="keyword">public</span> Shop <span class="title function_">queryWithLogicalExpire</span><span class="params">(Long id)</span> &#123;</span><br><span class="line">       <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> RedisConstants.CACHE_SHOP_KEY + id;</span><br><span class="line">       <span class="comment">//1.从redis查询商铺缓存</span></span><br><span class="line">       <span class="type">String</span> <span class="variable">shopJson</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().get(key);</span><br><span class="line">       <span class="comment">//2.判断是否存在</span></span><br><span class="line">       <span class="keyword">if</span> (StrUtil.isNotBlank(shopJson)) &#123;</span><br><span class="line">           <span class="comment">//3.存在,直接返回</span></span><br><span class="line">           <span class="keyword">return</span> JSONUtil.toBean(shopJson, Shop.class);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//4.命中，需要先把json反序列化为对象</span></span><br><span class="line">       <span class="type">RedisData</span> <span class="variable">redisData</span> <span class="operator">=</span> JSONUtil.toBean(shopJson, RedisData.class);</span><br><span class="line">       <span class="type">Shop</span> <span class="variable">shop</span> <span class="operator">=</span> JSONUtil.toBean((JSONObject) redisData.getData(), Shop.class);</span><br><span class="line">       <span class="type">LocalDateTime</span> <span class="variable">expireTime</span> <span class="operator">=</span> redisData.getExpireTime();</span><br><span class="line">       <span class="comment">//5.判断是否过期</span></span><br><span class="line">       <span class="keyword">if</span> (expireTime.isAfter(LocalDateTime.now()))&#123;</span><br><span class="line">           <span class="comment">//5.1.未过期直接返回缓存店铺信息</span></span><br><span class="line">           <span class="keyword">return</span> shop;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//5.2.已过期，需要缓存重建</span></span><br><span class="line">       <span class="comment">//6.缓存重建</span></span><br><span class="line">       <span class="comment">//6.1.获取互斥锁</span></span><br><span class="line">       <span class="type">String</span> <span class="variable">lockKey</span> <span class="operator">=</span> LOCK_SHOP_KEY + id;</span><br><span class="line">       <span class="type">boolean</span> <span class="variable">isLock</span> <span class="operator">=</span> tryLock(lockKey);</span><br><span class="line">       <span class="comment">//6.2.判断时候获取成功</span></span><br><span class="line">       <span class="keyword">if</span> (isLock)&#123;</span><br><span class="line">            <span class="comment">//6.3.成功，开启独立线程，实现缓存重建</span></span><br><span class="line">           CACHE_REBUILD_EXECUTOR.submit(() -&gt; &#123;</span><br><span class="line">              <span class="comment">//重建缓存</span></span><br><span class="line">               <span class="keyword">try</span> &#123;</span><br><span class="line">                   <span class="built_in">this</span>.saveShop2Redis(id,<span class="number">30L</span>);</span><br><span class="line">               &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                   <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">               &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                   <span class="comment">//释放锁</span></span><br><span class="line">                   onLock(lockKey);</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//6.4.返回</span></span><br><span class="line">       <span class="keyword">return</span> shop;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">saveShop2Redis</span><span class="params">(Long id,Long expireSeconds)</span>&#123;</span><br><span class="line">       <span class="comment">//1.查询店铺数据</span></span><br><span class="line">       <span class="type">Shop</span> <span class="variable">shop</span> <span class="operator">=</span> getById(id);</span><br><span class="line">       <span class="comment">//2.封装逻辑过期时间</span></span><br><span class="line">       <span class="type">RedisData</span> <span class="variable">redisData</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RedisData</span>();</span><br><span class="line">       redisData.setData(shop);</span><br><span class="line">       redisData.setExpireTime(LocalDateTime.now().plusSeconds(expireSeconds));</span><br><span class="line">       <span class="comment">//写入redis</span></span><br><span class="line">       stringRedisTemplate.opsForValue().set(CACHE_SHOP_KEY + id , JSONUtil.toJsonStr(redisData));</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">tryLock</span><span class="params">(String key)</span> &#123;</span><br><span class="line">       <span class="type">Boolean</span> <span class="variable">flag</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().setIfAbsent(key, <span class="string">&quot;1&quot;</span>, LOCK_SHOP_TTL, TimeUnit.SECONDS);</span><br><span class="line">       <span class="keyword">return</span> BooleanUtil.isTrue(flag);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">onLock</span><span class="params">(String key)</span> &#123;</span><br><span class="line">       stringRedisTemplate.delete(key);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>缓存雪崩</title>
      <link href="/2023/11/21/redis%E7%AC%94%E8%AE%B0/%E4%B8%AA%E4%BA%BA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%BC%93%E5%AD%98%E9%9B%AA%E5%B4%A9/"/>
      <url>/2023/11/21/redis%E7%AC%94%E8%AE%B0/%E4%B8%AA%E4%BA%BA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%BC%93%E5%AD%98%E9%9B%AA%E5%B4%A9/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/># 缓存雪崩<p><img src="https://gitee.com/Button_mkns/picgo/raw/master/img/image-20231121112235428.png" alt="image-20231121112235428"></p>]]></content>
      
      
      <categories>
          
          <category> 缓存 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>全局ID生成器</title>
      <link href="/2023/11/21/redis%E7%AC%94%E8%AE%B0/%E4%B8%AA%E4%BA%BA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%85%A8%E5%B1%80ID%E7%94%9F%E6%88%90%E5%99%A8/"/>
      <url>/2023/11/21/redis%E7%AC%94%E8%AE%B0/%E4%B8%AA%E4%BA%BA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%85%A8%E5%B1%80ID%E7%94%9F%E6%88%90%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/># 全局ID生成器<p><img src="https://gitee.com/Button_mkns/picgo/raw/master/img/image-20231122162313440.png" alt="image-20231122162313440"></p><p>代码实现</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">package com.hmdp.utils;</span><br><span class="line"></span><br><span class="line">import org.springframework.data.redis.core.StringRedisTemplate;</span><br><span class="line">import org.springframework.format.annotation.DateTimeFormat;</span><br><span class="line">import org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line">import java.time.LocalDateTime;</span><br><span class="line">import java.time.ZoneOffset;</span><br><span class="line">import java.time.format.DateTimeFormatter;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @author zhnaghao</span><br><span class="line"> * @create 2023-11-22-16:24</span><br><span class="line"> */</span><br><span class="line">@Component</span><br><span class="line">public class RedisIDWorker &#123;</span><br><span class="line">    /*开始时间戳*/</span><br><span class="line">    private static final long BEGIN_TIMESTAMP = 1640995200L;</span><br><span class="line">    private static final int CONUT_BITS = 32;</span><br><span class="line">    private StringRedisTemplate stringRedisTemplate;</span><br><span class="line"></span><br><span class="line">    public RedisIDWorker(StringRedisTemplate stringRedisTemplate) &#123;</span><br><span class="line">        this.stringRedisTemplate = stringRedisTemplate;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Long nextId(String keyPrefix)&#123;</span><br><span class="line">        //1.生成时间戳</span><br><span class="line">        LocalDateTime now = LocalDateTime.now();</span><br><span class="line">        long nowSecond = now.toEpochSecond(ZoneOffset.UTC);</span><br><span class="line">        long timeStap = nowSecond - BEGIN_TIMESTAMP;</span><br><span class="line">        //2.生成序列号</span><br><span class="line">        //2.1.获取当前日期，精确到天</span><br><span class="line">        String date = now.format(DateTimeFormatter.ofPattern(&quot;yyyy:MM:dd&quot;));</span><br><span class="line">        //2.2.自增长</span><br><span class="line">        Long count = stringRedisTemplate.opsForValue().increment(&quot;icr:&quot; + keyPrefix + &quot;:&quot; + date);</span><br><span class="line">        //3.拼接并且返回</span><br><span class="line"></span><br><span class="line">        return timeStap &lt;&lt; CONUT_BITS | count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        LocalDateTime time = LocalDateTime.of(2022, 1, 1, 0, 0, 0);</span><br><span class="line">        long second = time.toEpochSecond(ZoneOffset.UTC);</span><br><span class="line">        System.out.println(&quot;second = &quot; + second);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/Button_mkns/picgo/raw/master/img/image-20231122170729745.png" alt="image-20231122170729745"></p>]]></content>
      
      
      <categories>
          
          <category> Redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> redis&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;/&gt; </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>缓存工具封装</title>
      <link href="/2023/11/21/redis%E7%AC%94%E8%AE%B0/%E4%B8%AA%E4%BA%BA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%BC%93%E5%AD%98%E5%B7%A5%E5%85%B7%E5%B0%81%E8%A3%85/"/>
      <url>/2023/11/21/redis%E7%AC%94%E8%AE%B0/%E4%B8%AA%E4%BA%BA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%BC%93%E5%AD%98%E5%B7%A5%E5%85%B7%E5%B0%81%E8%A3%85/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/># 缓存工具封装<p><img src="https://gitee.com/Button_mkns/picgo/raw/master/img/image-20231122110753332.png" alt="image-20231122110753332"></p><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hmdp.utils;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> cn.hutool.core.util.BooleanUtil;</span><br><span class="line"><span class="keyword">import</span> cn.hutool.core.util.StrUtil;</span><br><span class="line"><span class="keyword">import</span> cn.hutool.json.JSONObject;</span><br><span class="line"><span class="keyword">import</span> cn.hutool.json.JSONUtil;</span><br><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.core.StringRedisTemplate;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Type;</span><br><span class="line"><span class="keyword">import</span> java.time.LocalDateTime;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"><span class="keyword">import</span> java.util.function.Function;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> com.hmdp.utils.RedisConstants.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> zhnaghao</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2023-11-22-11:12</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CacheClient</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> StringRedisTemplate stringRedisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">CacheClient</span><span class="params">(StringRedisTemplate stringRedisTemplate)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.stringRedisTemplate = stringRedisTemplate;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">set</span><span class="params">(String key, Object value, Long time, TimeUnit unit)</span> &#123;</span><br><span class="line">        stringRedisTemplate.opsForValue().set(key, JSONUtil.toJsonStr(value), time, unit);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setWithLogicalExprie</span><span class="params">(String key, Object value, Long time, TimeUnit unit)</span> &#123;</span><br><span class="line">        <span class="comment">//设置逻辑过期</span></span><br><span class="line">        <span class="type">RedisData</span> <span class="variable">redisData</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RedisData</span>();</span><br><span class="line">        redisData.setData(value);</span><br><span class="line">        redisData.setExpireTime(LocalDateTime.now().plusSeconds(unit.toSeconds(time)));</span><br><span class="line">        <span class="comment">//写入redis</span></span><br><span class="line">        stringRedisTemplate.opsForValue().set(key, JSONUtil.toJsonStr(redisData));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> &lt;R, ID&gt; R <span class="title function_">queryWithPassThrough</span><span class="params">(String keyPrefix, ID id, Class&lt;R&gt; type, Function&lt;ID, R&gt; dbFallback, Long time, TimeUnit unit)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> keyPrefix + id;</span><br><span class="line">        <span class="comment">//1.从redis查询商铺缓存</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">json</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().get(key);</span><br><span class="line">        <span class="comment">//2.判断是否存在</span></span><br><span class="line">        <span class="keyword">if</span> (StrUtil.isNotBlank(json)) &#123;</span><br><span class="line">            <span class="comment">//3.存在,直接返回</span></span><br><span class="line">            <span class="keyword">return</span> JSONUtil.toBean(json, type);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 判断命中的是否是空值</span></span><br><span class="line">        <span class="keyword">if</span> (json != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 返回错误信息</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//4.成功，根据id查询数据库</span></span><br><span class="line">        <span class="type">R</span> <span class="variable">r</span> <span class="operator">=</span> dbFallback.apply(id);</span><br><span class="line">        <span class="comment">//5.不存在，根据id查询数据库</span></span><br><span class="line">        <span class="keyword">if</span> (r == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">//将空值写入redis</span></span><br><span class="line">            stringRedisTemplate.opsForValue().set(key, <span class="string">&quot;&quot;</span>, CACHE_NULL_TTL, TimeUnit.MINUTES);</span><br><span class="line">            <span class="comment">//5.不存在，返回错误</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//6.存在，写入redis</span></span><br><span class="line">        <span class="built_in">this</span>.set(key, r, time, unit);</span><br><span class="line">        <span class="comment">//8.返回</span></span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建线程池</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">ExecutorService</span> <span class="variable">CACHE_REBUILD_EXECUTOR</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line">    <span class="comment">//通过逻辑过期解决缓存击穿问题</span></span><br><span class="line">    <span class="keyword">public</span> &lt;R,ID&gt; R <span class="title function_">queryWithLogicalExpire</span><span class="params">(String keyPreFix , ID id , Class&lt;R&gt; type , Function&lt;ID,R&gt; dbFallback,Long time, TimeUnit unit)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> RedisConstants.CACHE_SHOP_KEY + id;</span><br><span class="line">        <span class="comment">//1.从redis查询商铺缓存</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">json</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().get(key);</span><br><span class="line">        <span class="comment">//2.判断是否存在</span></span><br><span class="line">        <span class="keyword">if</span> (StrUtil.isNotBlank(json)) &#123;</span><br><span class="line">            <span class="comment">//3.存在,直接返回</span></span><br><span class="line">            <span class="keyword">return</span> JSONUtil.toBean(json, type);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//4.命中，需要先把json反序列化为对象</span></span><br><span class="line">        <span class="type">RedisData</span> <span class="variable">redisData</span> <span class="operator">=</span> JSONUtil.toBean(json, RedisData.class);</span><br><span class="line">        <span class="type">R</span> <span class="variable">r</span> <span class="operator">=</span> JSONUtil.toBean((JSONObject) redisData.getData(), type);</span><br><span class="line">        <span class="type">LocalDateTime</span> <span class="variable">expireTime</span> <span class="operator">=</span> redisData.getExpireTime();</span><br><span class="line">        <span class="comment">//5.判断是否过期</span></span><br><span class="line">        <span class="keyword">if</span> (expireTime.isAfter(LocalDateTime.now())) &#123;</span><br><span class="line">            <span class="comment">//5.1.未过期直接返回缓存店铺信息</span></span><br><span class="line">            <span class="keyword">return</span> r;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//5.2.已过期，需要缓存重建</span></span><br><span class="line">        <span class="comment">//6.缓存重建</span></span><br><span class="line">        <span class="comment">//6.1.获取互斥锁</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">lockKey</span> <span class="operator">=</span> LOCK_SHOP_KEY + id;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">isLock</span> <span class="operator">=</span> tryLock(lockKey);</span><br><span class="line">        <span class="comment">//6.2.判断时候获取成功</span></span><br><span class="line">        <span class="keyword">if</span> (isLock) &#123;</span><br><span class="line">            <span class="comment">//6.3.成功，开启独立线程，实现缓存重建</span></span><br><span class="line">            CACHE_REBUILD_EXECUTOR.submit(() -&gt; &#123;</span><br><span class="line">                <span class="comment">//重建缓存</span></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                   <span class="comment">//查询数据库</span></span><br><span class="line">                    <span class="type">R</span> <span class="variable">r1</span> <span class="operator">=</span> dbFallback.apply(id);</span><br><span class="line">                    <span class="comment">//写入redis</span></span><br><span class="line">                    <span class="built_in">this</span>.setWithLogicalExprie(key,r1,time,unit);</span><br><span class="line"></span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    <span class="comment">//释放锁</span></span><br><span class="line">                    onLock(lockKey);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//6.4.返回</span></span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">tryLock</span><span class="params">(String key)</span> &#123;</span><br><span class="line">        <span class="type">Boolean</span> <span class="variable">flag</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().setIfAbsent(key, <span class="string">&quot;1&quot;</span>, LOCK_SHOP_TTL, TimeUnit.SECONDS);</span><br><span class="line">        <span class="keyword">return</span> BooleanUtil.isTrue(flag);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">onLock</span><span class="params">(String key)</span> &#123;</span><br><span class="line">        stringRedisTemplate.delete(key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>调用方式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Shop</span> <span class="variable">shop</span> <span class="operator">=</span> cacheClient.queryWithLogicalExpire(</span><br><span class="line">    CACHE_SHOP_KEY, id, Shop.class, <span class="built_in">this</span>::getById, LOCK_SHOP_TTL, TimeUnit.SECONDS);</span><br><span class="line"><span class="type">Shop</span> <span class="variable">shop</span> <span class="operator">=</span> cacheClient.queryWithPassThrough(</span><br><span class="line">    CACHE_SHOP_KEY, id, Shop.class, <span class="built_in">this</span>::getById, CACHE_SHOP_TTL, TimeUnit.MINUTES);</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>缓存穿透</title>
      <link href="/2023/11/21/redis%E7%AC%94%E8%AE%B0/%E4%B8%AA%E4%BA%BA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F/"/>
      <url>/2023/11/21/redis%E7%AC%94%E8%AE%B0/%E4%B8%AA%E4%BA%BA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/># 缓存穿透<p><img src="https://gitee.com/Button_mkns/picgo/raw/master/img/image-20231121105917579.png" alt="image-20231121105917579"></p><p>缓存空对象案例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Result <span class="title function_">queryById</span><span class="params">(Long id)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> RedisConstants.CACHE_SHOP_KEY + id;</span><br><span class="line">    <span class="comment">//1.从redis查询商铺缓存</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">shopJson</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().get(key);</span><br><span class="line">    <span class="comment">//2.判断是否存在</span></span><br><span class="line">    <span class="keyword">if</span> (StrUtil.isNotBlank(shopJson)) &#123;</span><br><span class="line">        <span class="comment">//3.存在,直接返回</span></span><br><span class="line">        <span class="type">Shop</span> <span class="variable">shop</span> <span class="operator">=</span> JSONUtil.toBean(shopJson, Shop.class);</span><br><span class="line">        <span class="keyword">return</span> Result.ok(shop);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 判断命中的是否是空值</span></span><br><span class="line">    <span class="keyword">if</span> (shopJson != <span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="comment">// 返回错误信息</span></span><br><span class="line">        <span class="keyword">return</span> Result.fail(<span class="string">&quot;店铺信息不存在&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//4.不存在，根据id查询数据库</span></span><br><span class="line">    <span class="type">Shop</span> <span class="variable">shop</span> <span class="operator">=</span> getById(id);</span><br><span class="line">    <span class="keyword">if</span> (shop == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">//将空值写入redis</span></span><br><span class="line">        stringRedisTemplate.opsForValue().set(key,<span class="string">&quot;&quot;</span>,CACHE_NULL_TTL, TimeUnit.MINUTES);</span><br><span class="line">        <span class="comment">//5.不存在，返回错误</span></span><br><span class="line">        <span class="keyword">return</span> Result.fail(<span class="string">&quot;店铺不存在&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//6.存在，写入redis</span></span><br><span class="line">    stringRedisTemplate.opsForValue().set(key,JSONUtil.toJsonStr(shop),CACHE_SHOP_TTL, TimeUnit.MINUTES);</span><br><span class="line">    <span class="keyword">return</span> Result.ok(shop);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ThreadLocal</title>
      <link href="/2023/11/19/redis%E7%AC%94%E8%AE%B0/%E4%B8%AA%E4%BA%BA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/ThreadLocal/"/>
      <url>/2023/11/19/redis%E7%AC%94%E8%AE%B0/%E4%B8%AA%E4%BA%BA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/ThreadLocal/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/><h1 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h1><h3 id="1-ThreadLocal是什么？"><a href="#1-ThreadLocal是什么？" class="headerlink" title="1. ThreadLocal是什么？"></a>1. ThreadLocal是什么？</h3><p>从名字我们就可以看到<code>ThreadLocal</code> 叫做本地线程变量，意思是说，<code>ThreadLocal</code> 中填充的的是当前线程的变量，该变量对其他线程而言是封闭且隔离的，<code>ThreadLocal</code> 为变量在每个线程中创建了一个副本，这样每个线程都可以访问自己内部的副本变量。</p><p>从字面意思很容易理解，但是实际角度就没那么容易了，作为一个面试常问的点，使用场景也是很丰富。</p><ul><li>1、在进行对象跨层传递的时候，使用ThreadLocal可以避免多次传递，打破层次间的约束。</li><li>2、线程间数据隔离</li><li>3、进行事务操作，用于存储线程事务信息。</li><li>4、数据库连接，<code>Session</code>会话管理。</li></ul><h3 id="2-ThreadLocal怎么用？"><a href="#2-ThreadLocal怎么用？" class="headerlink" title="2. ThreadLocal怎么用？"></a>2. ThreadLocal怎么用？</h3><p>例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadLocalTest02</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        ThreadLocal&lt;String&gt; local = <span class="keyword">new</span> <span class="title class_">ThreadLocal</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        IntStream.range(<span class="number">0</span>, <span class="number">10</span>).forEach(i -&gt; <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            local.set(Thread.currentThread().getName() + <span class="string">&quot;:&quot;</span> + i);</span><br><span class="line">            System.out.println(<span class="string">&quot;线程：&quot;</span> + Thread.currentThread().getName() + <span class="string">&quot;,local:&quot;</span> + local.get());</span><br><span class="line">        &#125;).start());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">输出结果：</span><br><span class="line">线程：Thread-<span class="number">0</span>,local:Thread-<span class="number">0</span>:<span class="number">0</span></span><br><span class="line">线程：Thread-<span class="number">1</span>,local:Thread-<span class="number">1</span>:<span class="number">1</span></span><br><span class="line">线程：Thread-<span class="number">2</span>,local:Thread-<span class="number">2</span>:<span class="number">2</span></span><br><span class="line">线程：Thread-<span class="number">3</span>,local:Thread-<span class="number">3</span>:<span class="number">3</span></span><br><span class="line">线程：Thread-<span class="number">4</span>,local:Thread-<span class="number">4</span>:<span class="number">4</span></span><br><span class="line">线程：Thread-<span class="number">5</span>,local:Thread-<span class="number">5</span>:<span class="number">5</span></span><br><span class="line">线程：Thread-<span class="number">6</span>,local:Thread-<span class="number">6</span>:<span class="number">6</span></span><br><span class="line">线程：Thread-<span class="number">7</span>,local:Thread-<span class="number">7</span>:<span class="number">7</span></span><br><span class="line">线程：Thread-<span class="number">8</span>,local:Thread-<span class="number">8</span>:<span class="number">8</span></span><br><span class="line">线程：Thread-<span class="number">9</span>,local:Thread-<span class="number">9</span>:<span class="number">9</span></span><br></pre></td></tr></table></figure><p>从结果可以看到，每一个线程都有自己的local 值，这就是TheadLocal的基本使用 。</p><p>下面我们从源码的角度来分析一下，ThreadLocal的工作原理。</p><h3 id="3-ThreadLocal源码分析"><a href="#3-ThreadLocal源码分析" class="headerlink" title="3. ThreadLocal源码分析"></a>3. ThreadLocal源码分析</h3><p>1、<code>set</code> 方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Sets the current thread&#x27;s copy of this thread-local variable</span></span><br><span class="line"><span class="comment">     * to the specified value.  Most subclasses will have no need to</span></span><br><span class="line"><span class="comment">     * override this method, relying solely on the &#123;<span class="doctag">@link</span> #initialValue&#125;</span></span><br><span class="line"><span class="comment">     * method to set the values of thread-locals.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value the value to be stored in the current thread&#x27;s copy of</span></span><br><span class="line"><span class="comment">     *        this thread-local.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">set</span><span class="params">(T value)</span> &#123;</span><br><span class="line">        <span class="comment">//首先获取当前线程对象</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">        <span class="comment">//获取线程中变量 ThreadLocal.ThreadLocalMap</span></span><br><span class="line">        <span class="type">ThreadLocalMap</span> <span class="variable">map</span> <span class="operator">=</span> getMap(t);</span><br><span class="line">        <span class="comment">//如果不为空，</span></span><br><span class="line">        <span class="keyword">if</span> (map != <span class="literal">null</span>)</span><br><span class="line">            map.set(<span class="built_in">this</span>, value);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="comment">//如果为空，初始化该线程对象的map变量，其中key 为当前的threadlocal 变量</span></span><br><span class="line">            createMap(t, value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Create the map associated with a ThreadLocal. Overridden in</span></span><br><span class="line"><span class="comment">     * InheritableThreadLocal.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> t the current thread</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> firstValue value for the initial entry of the map</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="comment">//初始化线程内部变量 threadLocals ，key 为当前 threadlocal</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">createMap</span><span class="params">(Thread t, T firstValue)</span> &#123;</span><br><span class="line">        t.threadLocals = <span class="keyword">new</span> <span class="title class_">ThreadLocalMap</span>(<span class="built_in">this</span>, firstValue);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Construct a new map initially containing (firstKey, firstValue).</span></span><br><span class="line"><span class="comment">         * ThreadLocalMaps are constructed lazily, so we only create</span></span><br><span class="line"><span class="comment">         * one when we have at least one entry to put in it.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        ThreadLocalMap(ThreadLocal&lt;?&gt; firstKey, Object firstValue) &#123;</span><br><span class="line">            table = <span class="keyword">new</span> <span class="title class_">Entry</span>[INITIAL_CAPACITY];</span><br><span class="line">            <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> firstKey.threadLocalHashCode &amp; (INITIAL_CAPACITY - <span class="number">1</span>);</span><br><span class="line">            table[i] = <span class="keyword">new</span> <span class="title class_">Entry</span>(firstKey, firstValue);</span><br><span class="line">            size = <span class="number">1</span>;</span><br><span class="line">            setThreshold(INITIAL_CAPACITY);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Entry</span> <span class="keyword">extends</span> <span class="title class_">WeakReference</span>&lt;ThreadLocal&lt;?&gt;&gt; &#123;</span><br><span class="line">            <span class="comment">/** The value associated with this ThreadLocal. */</span></span><br><span class="line">            Object value;</span><br><span class="line"></span><br><span class="line">            Entry(ThreadLocal&lt;?&gt; k, Object v) &#123;</span><br><span class="line">                <span class="built_in">super</span>(k);</span><br><span class="line">                value = v;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>汇总下，<code>ThreadLocalMap</code> 为 <code>ThreadLocal</code> 的一个静态内部类，里面定义了<code>Entry</code> 来保存数据。而且是继承的弱引用。在<code>Entry</code>内部使用<code>ThreadLocal</code>作为<code>key</code>，使用我们设置的<code>value</code>作为<code>value</code>。</p><p>对于每个线程内部有个<code>ThreadLocal.ThreadLocalMap</code> 变量，存取值的时候，也是从这个容器中来获取。</p><p>2、<code>get</code>方法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">     * Returns the value in the current thread&#x27;s copy of this</span><br><span class="line">     * thread-local variable.  If the variable has no value for the</span><br><span class="line">     * current thread, it is first initialized to the value returned</span><br><span class="line">     * by an invocation of the &#123;@link #initialValue&#125; method.</span><br><span class="line">     *</span><br><span class="line">     * @return the current thread&#x27;s value of this thread-local</span><br><span class="line">     */</span><br><span class="line">    public T get() &#123;</span><br><span class="line">        Thread t = Thread.currentThread();</span><br><span class="line">        ThreadLocalMap map = getMap(t);</span><br><span class="line">        if (map != null) &#123;</span><br><span class="line">            ThreadLocalMap.Entry e = map.getEntry(this);</span><br><span class="line">            if (e != null) &#123;</span><br><span class="line">                @SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">                T result = (T)e.value;</span><br><span class="line">                return result;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return setInitialValue();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>首先获取当前线程，然后通过<code>key threadlocal</code> 获取 设置的<code>value</code> 。</p><h3 id="4-ThreadLocal-内存泄漏问题"><a href="#4-ThreadLocal-内存泄漏问题" class="headerlink" title="4. ThreadLocal 内存泄漏问题"></a>4. ThreadLocal 内存泄漏问题</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">         * The entries in this hash map extend WeakReference, using</span></span><br><span class="line"><span class="comment">         * its main ref field as the key (which is always a</span></span><br><span class="line"><span class="comment">         * ThreadLocal object).  Note that null keys (i.e. entry.get()</span></span><br><span class="line"><span class="comment">         * == null) mean that the key is no longer referenced, so the</span></span><br><span class="line"><span class="comment">         * entry can be expunged from table.  Such entries are referred to</span></span><br><span class="line"><span class="comment">         * as &quot;stale entries&quot; in the code that follows.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Entry</span> <span class="keyword">extends</span> <span class="title class_">WeakReference</span>&lt;ThreadLocal&lt;?&gt;&gt; &#123;</span><br><span class="line">            <span class="comment">/** The value associated with this ThreadLocal. */</span></span><br><span class="line">            Object value;</span><br><span class="line"></span><br><span class="line">            Entry(ThreadLocal&lt;?&gt; k, Object v) &#123;</span><br><span class="line">                <span class="built_in">super</span>(k);</span><br><span class="line">                value = v;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>如果 <code>key threadlocal</code> 为 <code>null</code> 了，这个 <code>entry</code> 就可以清除了。</p><p><code>ThreadLocal</code>是一个弱引用，当为<code>null</code>时，会被当成垃圾回收 。</p><p><img src="https://gitee.com/Button_mkns/picgo/raw/master/img/image-20231116094810272.png" alt="image-20231116094810272"></p><p><strong>重点来了，突然我们ThreadLocal是null了，也就是要被垃圾回收器回收了，但是此时我们的ThreadLocalMap（thread  的内部属性）生命周期和Thread的一样，它不会回收，这时候就出现了一个现象。那就是ThreadLocalMap的key没了，但是value还在，这就造成了内存泄漏。</strong></p><p>解决办法：使用完<code>ThreadLocal</code>后，执行<code>remove</code>操作，避免出现内存溢出情况。</p><p>所以 如同 <code>lock</code> 的操作 最后要执行解锁操作一样，<code>ThreadLocal</code>使用完毕一定记得执行remove 方法，清除当前线程的数值。</p><p>如果不<code>remove</code> 当前线程对应的<code>VALUE</code> ,就会一直存在这个值。</p><p>使用了线程池，可以达到“线程复用”的效果。但是归还线程之前记得清除<code>ThreadLocalMap</code>，要不然再取出该线程的时候，<code>ThreadLocal</code>变量还会存在。这就不仅仅是内存泄露的问题了，整个业务逻辑都可能会出错。</p><h3 id="5-为什么key使用弱引用？"><a href="#5-为什么key使用弱引用？" class="headerlink" title="5. 为什么key使用弱引用？"></a>5. 为什么key使用弱引用？</h3><p>如果使用强引用，当<code>ThreadLocal</code> 对象的引用（强引用）被回收了，<code>ThreadLocalMap</code>本身依然还持有<code>ThreadLocal</code>的强引用，如果没有手动删除这个key ,则<code>ThreadLocal</code>不会被回收，所以只要当前线程不消亡，<code>ThreadLocalMap</code>引用的那些对象就不会被回收， 可以认为这导致<code>Entry</code>内存泄漏。</p><p>附：强引用-软引用-弱引用</p><ul><li>强引用：普通的引用，强引用指向的对象不会被回收；</li><li>软引用：仅有软引用指向的对象，只有发生gc且内存不足，才会被回收；</li><li>弱引用：仅有弱引用指向的对象，只要发生gc就会被回收。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 知识碎片 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>接口声明</title>
      <link href="/2023/11/18/%E7%9F%A5%E8%AF%86%E7%A2%8E%E7%89%87/%E6%8E%A5%E5%8F%A3%E5%A3%B0%E6%98%8E/"/>
      <url>/2023/11/18/%E7%9F%A5%E8%AF%86%E7%A2%8E%E7%89%87/%E6%8E%A5%E5%8F%A3%E5%A3%B0%E6%98%8E/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/><p>1.Controller上添加   @Api(tags &#x3D; “该Contreller的功能”)</p><p>2.某个子接口上添加   @ApiOperation(“该子方法的功能”)</p><p><img src="https://gitee.com/Button_mkns/picgo/raw/master/img/image-20231117090624347.png" alt="image-20231117090624347"></p>]]></content>
      
      
      <categories>
          
          <category> 知识碎片 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 框架知识 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mybatis插件的使用</title>
      <link href="/2023/11/17/%E7%9F%A5%E8%AF%86%E7%A2%8E%E7%89%87/mybatis%E6%8E%A7%E5%88%B6%E5%8F%B0%E8%BE%93%E5%87%BAsql/"/>
      <url>/2023/11/17/%E7%9F%A5%E8%AF%86%E7%A2%8E%E7%89%87/mybatis%E6%8E%A7%E5%88%B6%E5%8F%B0%E8%BE%93%E5%87%BAsql/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/><h2 id="Mybatis-Log-plugin-插件不生效问题"><a href="#Mybatis-Log-plugin-插件不生效问题" class="headerlink" title="Mybatis Log plugin 插件不生效问题"></a><a href="https://so.csdn.net/so/search?q=Mybatis&spm=1001.2101.3001.7020">Mybatis</a> Log plugin 插件不生效问题</h2><p>经查找发现是因为没有添加配置，添加配置之后就能在Mybatis Log（或者点击 TooL—Mybatis Log Plugin就会在右下角出现Mybatis Log控制台）控制台能看见输出的完整sql。<br> 配置文件如下：</p><h3 id="application配置："><a href="#application配置：" class="headerlink" title="application配置："></a>application配置：</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mybatis-plus.configuration.log-impl=org.apache.ibatis.logging.stdout.StdOutImpl</span><br></pre></td></tr></table></figure><h3 id="yml配置"><a href="#yml配置" class="headerlink" title="yml配置"></a>yml配置</h3><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Mybatis log plugin 插件输出日志配置</span></span><br><span class="line"><span class="attr">mybatis-plus:</span></span><br><span class="line">  <span class="attr">configuration:</span></span><br><span class="line">    <span class="attr">log-impl:</span> <span class="string">org.apache.ibatis.logging.stdout.StdOutImpl</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 知识碎片 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 框架知识 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>jsr303</title>
      <link href="/2023/11/16/%E7%9F%A5%E8%AF%86%E7%A2%8E%E7%89%87/jsr303/"/>
      <url>/2023/11/16/%E7%9F%A5%E8%AF%86%E7%A2%8E%E7%89%87/jsr303/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/><h1 id="jsr303常用注解"><a href="#jsr303常用注解" class="headerlink" title="jsr303常用注解"></a><strong>jsr303常用注解</strong></h1><p><img src="https://gitee.com/Button_mkns/picgo/raw/master/img/image-20231030111839085.png" alt="image-20231030111839085"></p><h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><p>Hibernate 中填充一部分</p><p><img src="https://gitee.com/Button_mkns/picgo/raw/master/img/image-20231030112210956.png" alt="image-20231030112210956"></p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><h4 id="依赖"><a href="#依赖" class="headerlink" title="依赖"></a>依赖</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- https://mvnrepository.com/artifact/org.hibernate.validator/hibernate-validator --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.hibernate.validator<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>hibernate-validator<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>6.0.16.Final<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="给要校验的javaBean上标注校验注解"><a href="#给要校验的javaBean上标注校验注解" class="headerlink" title="给要校验的javaBean上标注校验注解"></a>给要校验的javaBean上标注校验注解</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ToString</span></span><br><span class="line"><span class="meta">@Getter</span></span><br><span class="line"><span class="meta">@Setter</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UmsAdminParam</span> &#123;</span><br><span class="line">    <span class="comment">//规定长度</span></span><br><span class="line">    <span class="meta">@Length(min = 6, max = 19, message = &quot;用户名长度是6-18位&quot;)</span></span><br><span class="line">    <span class="meta">@ApiModelProperty(value = &quot;用户名&quot;, required = true)</span></span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line">    <span class="meta">@ApiModelProperty(value = &quot;密码&quot;, required = true)</span></span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line">    <span class="comment">//不能是空的</span></span><br><span class="line">    <span class="meta">@NotEmpty</span></span><br><span class="line">    <span class="meta">@ApiModelProperty(value = &quot;用户头像&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String icon;</span><br><span class="line">    <span class="meta">@Email(message = &quot;邮箱格式错误&quot;)</span></span><br><span class="line">    <span class="meta">@ApiModelProperty(value = &quot;邮箱&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String email;</span><br><span class="line">    <span class="meta">@NotNull</span></span><br><span class="line">    <span class="meta">@ApiModelProperty(value = &quot;用户昵称&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String nickName;</span><br><span class="line">    <span class="meta">@ApiModelProperty(value = &quot;备注&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String note;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="告诉spring这个数据需要校验-Valid同时在方法上添加-Validated"><a href="#告诉spring这个数据需要校验-Valid同时在方法上添加-Validated" class="headerlink" title="告诉spring这个数据需要校验@Valid同时在方法上添加@Validated"></a>告诉spring这个数据需要校验@Valid同时在方法上添加@Validated</h3><p>@Valid属于javax的 不抛异常</p><p>@Validated属于spring用AOP拦截会抛异常 </p><blockquote><p>推荐同时使用</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">    * 新增养修信息预约</span><br><span class="line">    */</span><br><span class="line">   @PreAuthorize(&quot;@ss.hasPermi(&#x27;appointment:info:add&#x27;)&quot;)</span><br><span class="line">   @Log(title = &quot;养修信息预约&quot;, businessType = BusinessType.INSERT)</span><br><span class="line">   @PostMapping</span><br><span class="line">   public AjaxResult add(@Validated @RequestBody BusAppointmentVo busAppointment)</span><br><span class="line">   &#123;</span><br><span class="line">       return toAjax(busAppointmentService.insertBusAppointment(busAppointment));</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/Button_mkns/picgo/raw/master/img/image-20231030112637441.png" alt="image-20231030112637441"></p><h3 id="感知校验成功-x2F-失败"><a href="#感知校验成功-x2F-失败" class="headerlink" title="感知校验成功&#x2F;失败"></a>感知校验成功&#x2F;失败</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">Stringregister</span><span class="params">(<span class="meta">@Valid</span> <span class="meta">@RequestBody</span> UmsAdminParam user,BindingResult result)</span> &#123;</span><br><span class="line">        <span class="comment">//得到所有错误信息计数</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">errorCount</span> <span class="operator">=</span> result.getErrorCount();</span><br><span class="line">        <span class="comment">//错误数大于0</span></span><br><span class="line">        <span class="keyword">if</span> (errorCount&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="comment">//得到所有错误</span></span><br><span class="line">            List&lt;FieldError&gt; fieldErrors = result.getFieldErrors();</span><br><span class="line">            <span class="comment">//迭代错误</span></span><br><span class="line">            fieldErrors.forEach((fieldError)-&gt;&#123;</span><br><span class="line">            <span class="comment">//错误信息</span></span><br><span class="line">                <span class="type">String</span> <span class="variable">field</span> <span class="operator">=</span> fieldError.getField();</span><br><span class="line">                log.debug(<span class="string">&quot;属性：&#123;&#125;,传来的值是：&#123;&#125;,出错的提示消息：&#123;&#125;&quot;</span>,</span><br><span class="line">                        field,fieldError.getRejectedValue(),fieldError.getDefaultMessage());</span><br><span class="line">            &#125;);</span><br><span class="line">            <span class="keyword">return</span> fieldError.getRejectedValue()+<span class="string">&quot;出错:&quot;</span>+fieldError.getDefaultMessage();</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">&quot;登录成功&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 知识碎片 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java规范 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>事务</title>
      <link href="/2023/11/16/%E7%9F%A5%E8%AF%86%E7%A2%8E%E7%89%87/%E4%BA%8B%E5%8A%A1/"/>
      <url>/2023/11/16/%E7%9F%A5%E8%AF%86%E7%A2%8E%E7%89%87/%E4%BA%8B%E5%8A%A1/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/><p>在方法前加注解：**@Transactional**  可以令整个方法处于一个事物内 ， 如果某一个程序执行出错则会对整体进行回滚。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="meta">@Transactional</span></span><br><span class="line">    <span class="keyword">public</span> Result <span class="title function_">update</span><span class="params">(Shop shop)</span> &#123;</span><br><span class="line">        <span class="type">Long</span> <span class="variable">id</span> <span class="operator">=</span> shop.getId();</span><br><span class="line">        <span class="keyword">if</span> (id == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> Result.fail(<span class="string">&quot;店铺id不能为空&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//1.更新数据库</span></span><br><span class="line">            updateById(shop);</span><br><span class="line">        <span class="comment">//2.删除缓存</span></span><br><span class="line">        stringRedisTemplate.delete(RedisConstants.CACHE_SHOP_KEY + shop.getId());</span><br><span class="line">        <span class="keyword">return</span> Result.ok();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 知识碎片 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 框架知识 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis常见命令</title>
      <link href="/2023/11/14/redis%E7%AC%94%E8%AE%B0/%E4%B8%AA%E4%BA%BA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/redis%E5%85%A5%E9%97%A8/"/>
      <url>/2023/11/14/redis%E7%AC%94%E8%AE%B0/%E4%B8%AA%E4%BA%BA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/redis%E5%85%A5%E9%97%A8/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/><h1 id="Redis常见命令"><a href="#Redis常见命令" class="headerlink" title="Redis常见命令"></a>Redis常见命令</h1><h2 id="Redis通用命令"><a href="#Redis通用命令" class="headerlink" title="Redis通用命令"></a>Redis通用命令</h2><p>通用指令是部分数据类型的，都可以使用的指令，常见的有：</p><p><strong>redis-cli： -a</strong> <strong>admin</strong> 命令行连接redis使用redis</p><p><img src="https://gitee.com/Button_mkns/picgo/raw/master/img/image-20231114151950994.png" alt="image-20231114151950994"></p><p><strong>lKEYS</strong>：查看符合模板的所有key</p><p><strong>lDEL</strong>：删除一个指定的key</p><p><strong>lEXISTS</strong>：判断key是否存在</p><p><strong>lEXPIRE</strong>：给一个key设置有效期，有效期到期时该key会被自动删除</p><p><strong>lTTL</strong>：查看一个KEY的剩余有效期</p><p>通过<strong>help</strong> [command] 可以查看一个命令的具体用法，例如：</p><p><img src="https://gitee.com/Button_mkns/picgo/raw/master/img/image-20231114135849818.png" alt="image-20231114135849818"></p><h3 id="String类型"><a href="#String类型" class="headerlink" title="String类型"></a>String类型</h3><p><strong>String</strong>类型，也就是<strong>字符串类型</strong>，是Redis中最简单的存储类型。</p><p>其<strong>value是字符串</strong>，不过根据字符串的格式不同，又可以分为3类：</p><p><strong>lstring</strong>：普通字符串</p><p><strong>lint</strong>：整数类型，可以做自增、自减操作</p><p><strong>lfloat</strong>：浮点类型，可以做自增、自减操作</p><p>不管是哪种格式，底层都是字节数组形式存储，只不过是编码方式不同。字符串类型的最大空间不能超过512m.</p><p><img src="https://gitee.com/Button_mkns/picgo/raw/master/img/image-20231114140653141.png" alt="image-20231114140653141"></p><h4 id="String类型的常见命令"><a href="#String类型的常见命令" class="headerlink" title="String类型的常见命令"></a>String类型的常见命令</h4><p>String的常见命令有：</p><ul><li><strong>lSET</strong>：添加或者修改已经存在的一个String类型的键值对</li><li><strong>lGET</strong>：根据key获取String类型的value</li><li><strong>lMSET</strong>：批量添加多个String类型的键值对</li><li><strong>lMGET</strong>：根据多个key获取多个String类型的value</li><li><strong>lINCR</strong>：让一个整型的key自增1</li><li><strong>lINCRBY</strong>:让一个整型的key自增并指定步长，例如：incrby num 2 让num值自增2</li><li><strong>lINCRBYFLOAT</strong>：让一个浮点类型的数字自增并指定步长</li><li><strong>lSETNX</strong>：添加一个String类型的键值对，前提是这个key不存在，否则不执行</li><li><strong>lSETEX</strong>：添加一个String类型的键值对，并且指定有效期</li></ul><h4 id="key的结构"><a href="#key的结构" class="headerlink" title="key的结构"></a>key的结构</h4><p><strong>Redis的key允许有多个单词形成层级结构，多个单词之间用’:’隔开，格式如下：</strong></p><p><img src="https://gitee.com/Button_mkns/picgo/raw/master/img/image-20231114141827851.png" alt="image-20231114141827851"></p><p>这个格式并非固定，也可以根据自己的需求来删除或添加词条。</p><p>例如我们的项目名称叫 heima，有user和product两种不同类型的数据，我们可以这样定义key：</p><ul><li>uuser相关的key：heima:user:1</li><li>uproduct相关的key：heima:product:1</li></ul><p><strong>如果Value是一个Java对象，例如一个User对象，则可以将对象序列化为JSON字符串后存储：</strong></p><p><img src="https://gitee.com/Button_mkns/picgo/raw/master/img/image-20231114141921432.png" alt="image-20231114141921432"></p><h3 id="Hash类型"><a href="#Hash类型" class="headerlink" title="Hash类型"></a>Hash类型</h3><p>Hash类型，也叫散列，其value是一个无序字典，类似于Java中的HashMap结构。</p><p>String结构是将对象序列化为JSON字符串后存储，当需要修改对象某个字段时很不方便：</p><p><img src="https://gitee.com/Button_mkns/picgo/raw/master/img/image-20231114150342511.png" alt="image-20231114150342511"></p><p>Hash结构可以将对象中的每个字段独立存储，可以针对单个字段做CRUD：</p><p><img src="https://gitee.com/Button_mkns/picgo/raw/master/img/image-20231114150526277.png" alt="image-20231114150526277"></p><h4 id="Hash类型的常见命令"><a href="#Hash类型的常见命令" class="headerlink" title="Hash类型的常见命令"></a>Hash类型的常见命令</h4><p>Hash的常见命令有：</p><ul><li><strong>lHSET</strong> key field value：添加或者修改hash类型key的field的值</li><li><strong>lHGET</strong> key field：获取一个hash类型key的field的值</li><li><strong>lHMSET</strong>：批量添加多个hash类型key的field的值</li><li><strong>lHMGET</strong>：批量获取多个hash类型key的field的值</li><li><strong>lHGETALL</strong>：获取一个hash类型的key中的所有的field和value</li><li><strong>lHKEYS</strong>：获取一个hash类型的key中的所有的field</li><li><strong>lHVALS</strong>：获取一个hash类型的key中的所有的value</li><li><strong>lHINCRBY</strong>:让一个hash类型key的字段值自增并指定步长</li><li><strong>lHSETNX</strong>：添加一个hash类型的key的field值，前提是这个field不存在，否则不执行</li></ul><h3 id="List类型"><a href="#List类型" class="headerlink" title="List类型"></a>List类型</h3><p>Redis中的List类型与Java中的LinkedList类似，可以看做是一个双向链表结构。既可以支持正向检索和也可以支持反向检索。</p><p>特征也与LinkedList类似：</p><ul><li><strong>有序</strong></li><li><strong>元素可以重复</strong></li><li><strong>插入和删除快</strong></li><li><strong>查询速度一般</strong></li></ul><p>常用来存储一个有序数据，例如：朋友圈点赞列表，评论列表等。</p><h4 id="List类型的常见命令"><a href="#List类型的常见命令" class="headerlink" title="List类型的常见命令"></a>List类型的常见命令</h4><p>List的常见命令有：</p><ul><li><strong>lLPUSH</strong> key element … ：向列表左侧插入一个或多个元素</li><li><strong>lLPOP</strong> key：移除并返回列表左侧的第一个元素，没有则返回nil</li><li><strong>lRPUSH</strong> key element … ：向列表右侧插入一个或多个元素</li><li><strong>lRPOP</strong> key：移除并返回列表右侧的第一个元素</li><li><strong>lLRANGE</strong> key star end：返回一段角标范围内的所有元素</li><li><strong>lBLPOP</strong>和<strong>BRPOP</strong>：与<strong>LPOP</strong>和<strong>RPOP</strong>类似，只不过在没有元素时等待指定时间，而不是直接返回nil</li></ul><p><img src="https://gitee.com/Button_mkns/picgo/raw/master/img/image-20231114153420944.png" alt="image-20231114153420944"></p><h3 id="Set类型"><a href="#Set类型" class="headerlink" title="Set类型"></a>Set类型</h3><p>Redis的Set结构与Java中的HashSet类似，可以看做是一个value为null的HashMap。因为也是一个hash表，因此具备与HashSet类似的特征：</p><ul><li>无序</li><li>元素不可重复</li><li>查找快</li><li>支持交集、并集、差集等功能</li></ul><h4 id="Set类型的常见命令"><a href="#Set类型的常见命令" class="headerlink" title="Set类型的常见命令"></a>Set类型的常见命令</h4><p>String的常见命令有：</p><ul><li><strong>lSADD</strong> key member … ：向set中添加一个或多个元素</li><li><strong>lSREM</strong> key member … : 移除set中的指定元素</li><li><strong>lSCARD</strong> key： 返回set中元素的个数</li><li><strong>lSISMEMBER</strong> key member：判断一个元素是否存在于set中</li><li><strong>lSMEMBERS</strong>：获取set中的所有元素</li><li><strong>lSINTER</strong> key1 key2 … ：求key1与key2的交集</li><li><strong>lSDIFF</strong> key1 key2 … ：求key1与key2的差集</li><li><strong>lSUNION</strong> key1 key2 ..：求key1和key2的并集</li></ul><h3 id="SortedSet类型"><a href="#SortedSet类型" class="headerlink" title="SortedSet类型"></a>SortedSet类型</h3><p>Redis的SortedSet是一个可排序的set集合，与Java中的TreeSet有些类似，但底层数据结构却差别很大。SortedSet中的每一个元素都带有一个score属性，可以基于score属性对元素排序，底层的实现是一个跳表（SkipList）加 hash表。</p><p>SortedSet具备下列特性：</p><ul><li>可排序</li><li>元素不重复</li><li>查询速度快</li></ul><p>因为SortedSet的可排序特性，经常被用来实现排行榜这样的功能。</p><h4 id="SortedSet类型的常见命令"><a href="#SortedSet类型的常见命令" class="headerlink" title="SortedSet类型的常见命令"></a>SortedSet类型的常见命令</h4><p>SortedSet的常见命令有：</p><ul><li><strong>ZADD</strong> key score member：添加一个或多个元素到sorted set ，如果已经存在则更新其score值</li><li><strong>ZREM</strong> key member：删除sorted set中的一个指定元素</li><li><strong>ZSCORE</strong> key member : 获取sorted set中的指定元素的score值</li><li><strong>ZRANK</strong> key member：获取sorted set 中的指定元素的排名</li><li><strong>ZCARD</strong> key：获取sorted set中的元素个数</li><li><strong>ZCOUNT</strong> key min max：统计score值在给定范围内的所有元素的个数</li><li><strong>ZINCRBY</strong> key increment member：让sorted set中的指定元素自增，步长为指定的increment值</li><li><strong>ZRANGE</strong> key min max：按照score排序后，获取指定排名范围内的元素</li><li><strong>ZRANGEBYSCORE</strong> key min max：按照score排序后，获取指定score范围内的元素</li><li><strong>ZDIFF</strong>、<strong>ZINTER</strong>、<strong>ZUNION</strong>：求差集、交集、并集</li></ul><p><strong>注意</strong>：所有的排名默认都是升序，如果降序则在命令Z后面添加<strong>REV</strong>即可</p>]]></content>
      
      
      <categories>
          
          <category> Redis常见命令 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>redis客户端SpringDataRedis的简单使用</title>
      <link href="/2023/11/11/redis%E7%AC%94%E8%AE%B0/%E4%B8%AA%E4%BA%BA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/redis%E5%AE%A2%E6%88%B7%E7%AB%AF/"/>
      <url>/2023/11/11/redis%E7%AC%94%E8%AE%B0/%E4%B8%AA%E4%BA%BA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/redis%E5%AE%A2%E6%88%B7%E7%AB%AF/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/><h1 id="redis客户端SpringDataRedis的简单使用"><a href="#redis客户端SpringDataRedis的简单使用" class="headerlink" title="redis客户端SpringDataRedis的简单使用"></a>redis客户端SpringDataRedis的简单使用</h1><p><strong>SpringDataRedis</strong>快速入门</p><p>SpringDataRedis中提供了RedisTemplate工具类，其中封装了各种对Redis的操作。并且将不同数据类型的操作API封装到了不同的类型中：</p><p><img src="https://gitee.com/Button_mkns/picgo/raw/master/img/image-20231115091641669.png" alt="image-20231115091641669"></p><p>一、引入依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--redis依赖--&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">       <span class="comment">&lt;!--common-pool--&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.commons<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-pool2<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>二、编写配置文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">spring:</span><br><span class="line">  redis:</span><br><span class="line">    host: 192.168.12.128</span><br><span class="line">    port: 6379</span><br><span class="line">    password: admin</span><br><span class="line">    lettuce:</span><br><span class="line">      pool:</span><br><span class="line">        max-active: 8</span><br><span class="line">        max-idle: 8</span><br><span class="line">        min-idle: 0</span><br><span class="line">        max-wait: 100ms</span><br></pre></td></tr></table></figure><p>三、编写序列化工具类（可以省略使用springBoot的序列化工具）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.button.demo_redis.redis.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.connection.RedisConnectionFactory;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.core.RedisTemplate;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.serializer.GenericJackson2JsonRedisSerializer;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.serializer.RedisSerializer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.net.UnknownHostException;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> zhnaghao</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2023-11-14-17:55</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedisConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> RedisTemplate&lt;String,Object&gt; <span class="title function_">redisTemplate</span><span class="params">(RedisConnectionFactory connectionFactory)</span>&#123;</span><br><span class="line">        <span class="comment">//创建RedisTemplate对象</span></span><br><span class="line">        RedisTemplate&lt;String, Object&gt; template = <span class="keyword">new</span> <span class="title class_">RedisTemplate</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">//设置连接工厂</span></span><br><span class="line">        template.setConnectionFactory(connectionFactory);</span><br><span class="line">        <span class="comment">//创建json序列化工具</span></span><br><span class="line">        <span class="type">GenericJackson2JsonRedisSerializer</span> <span class="variable">jsonRedisSerializer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GenericJackson2JsonRedisSerializer</span>();</span><br><span class="line">        <span class="comment">//设置key的序列化</span></span><br><span class="line">        template.setKeySerializer(RedisSerializer.string());</span><br><span class="line">        template.setHashKeySerializer(RedisSerializer.string());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//设置value的序列化</span></span><br><span class="line">        template.setValueSerializer(jsonRedisSerializer);</span><br><span class="line">        template.setHashValueSerializer(jsonRedisSerializer);</span><br><span class="line">        <span class="comment">//返回</span></span><br><span class="line">        <span class="keyword">return</span> template;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>四、测试用例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.button.demo_redis;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.button.demo_redis.pojo.User;</span><br><span class="line"><span class="keyword">import</span> org.junit.jupiter.api.Test;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.test.context.SpringBootTest;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.core.RedisTemplate;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DemoRedisApplicationTests</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RedisTemplate&lt;String,Object&gt; redisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">testString</span><span class="params">()</span> &#123;</span><br><span class="line">        redisTemplate.opsForValue().set(<span class="string">&quot;name&quot;</span> , <span class="string">&quot;胡歌&quot;</span>);</span><br><span class="line">        <span class="type">Object</span> <span class="variable">name</span> <span class="operator">=</span> redisTemplate.opsForValue().get(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;name = &quot;</span> + name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">testSaveUser</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//写入数据</span></span><br><span class="line">        redisTemplate.opsForValue().set(<span class="string">&quot;user:100&quot;</span> , <span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;古河&quot;</span>,<span class="string">&quot;21&quot;</span>));</span><br><span class="line">        <span class="comment">//获取数据</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">o</span> <span class="operator">=</span> redisTemplate.opsForValue().get(<span class="string">&quot;user:100&quot;</span>);</span><br><span class="line">        System.out.println(o);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.button.demo_redis;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.button.demo_redis.pojo.User;</span><br><span class="line"><span class="keyword">import</span> com.fasterxml.jackson.core.JsonProcessingException;</span><br><span class="line"><span class="keyword">import</span> com.fasterxml.jackson.databind.ObjectMapper;</span><br><span class="line"><span class="keyword">import</span> org.junit.jupiter.api.Test;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.test.context.SpringBootTest;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.core.RedisTemplate;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.core.StringRedisTemplate;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">RedisStringnTests</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> StringRedisTemplate stringRedisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">testString</span><span class="params">()</span> &#123;</span><br><span class="line">        stringRedisTemplate.opsForValue().set(<span class="string">&quot;name&quot;</span> , <span class="string">&quot;胡哥哥&quot;</span>);</span><br><span class="line">        <span class="type">Object</span> <span class="variable">name</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().get(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;name = &quot;</span> + name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">ObjectMapper</span> <span class="variable">mapper</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectMapper</span>();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">testSaveUser</span><span class="params">()</span> <span class="keyword">throws</span> JsonProcessingException &#123;</span><br><span class="line">        <span class="comment">// 创建对象</span></span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;小虎&quot;</span>, <span class="string">&quot;33&quot;</span>);</span><br><span class="line">        <span class="comment">//手动序列化</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">json</span> <span class="operator">=</span> mapper.writeValueAsString(user);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//写入数据</span></span><br><span class="line">        stringRedisTemplate.opsForValue().set(<span class="string">&quot;user:200&quot;</span> , json);</span><br><span class="line">        <span class="comment">//获取数据</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">jsonUser</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().get(<span class="string">&quot;user:200&quot;</span>);</span><br><span class="line">        <span class="comment">//手动反序列化</span></span><br><span class="line">        <span class="type">User</span> <span class="variable">user1</span> <span class="operator">=</span> mapper.readValue(jsonUser , User.class);</span><br><span class="line">        System.out.println(user1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>[^使用springBoot自带的序列化工具]: </p>]]></content>
      
      
      <categories>
          
          <category> Redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java中的IntStream range()方法的使用</title>
      <link href="/2023/11/08/%E7%9F%A5%E8%AF%86%E7%A2%8E%E7%89%87/IntStream%20range()/"/>
      <url>/2023/11/08/%E7%9F%A5%E8%AF%86%E7%A2%8E%E7%89%87/IntStream%20range()/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/># Java中的IntStream range()方法的使用<p>Java中，IntStream是一个接口，继承BaseStream。</p><p><img src="https://gitee.com/Button_mkns/picgo/raw/master/img/image-20231116091719904.png" alt="image-20231116091719904"></p><p><strong>源码：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Returns a sequential ordered &#123;<span class="doctag">@code</span> IntStream&#125; from &#123;<span class="doctag">@code</span> startInclusive&#125;</span></span><br><span class="line"><span class="comment">    * (inclusive) to &#123;<span class="doctag">@code</span> endExclusive&#125; (exclusive) by an incremental step of</span></span><br><span class="line"><span class="comment">    * &#123;<span class="doctag">@code</span> 1&#125;.</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@apiNote</span></span></span><br><span class="line"><span class="comment">    * &lt;p&gt;An equivalent sequence of increasing values can be produced</span></span><br><span class="line"><span class="comment">    * sequentially using a &#123;<span class="doctag">@code</span> for&#125; loop as follows:</span></span><br><span class="line"><span class="comment">    * &lt;pre&gt;&#123;<span class="doctag">@code</span></span></span><br><span class="line"><span class="comment">    *     for (int i = startInclusive; i &lt; endExclusive ; i++) &#123; ... &#125;</span></span><br><span class="line"><span class="comment">    * &#125;&lt;/pre&gt;</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> startInclusive the (inclusive) initial value</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> endExclusive the exclusive upper bound</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span> a sequential &#123;<span class="doctag">@code</span> IntStream&#125; for the range of &#123;<span class="doctag">@code</span> int&#125;</span></span><br><span class="line"><span class="comment">    *         elements</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> IntStream <span class="title function_">range</span><span class="params">(<span class="type">int</span> startInclusive, <span class="type">int</span> endExclusive)</span> &#123;</span><br><span class="line">       <span class="keyword">if</span> (startInclusive &gt;= endExclusive) &#123;</span><br><span class="line">           <span class="keyword">return</span> empty();</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           <span class="keyword">return</span> StreamSupport.intStream(</span><br><span class="line">                   <span class="keyword">new</span> <span class="title class_">Streams</span>.RangeIntSpliterator(startInclusive, endExclusive, <span class="literal">false</span>), <span class="literal">false</span>);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p><strong>说明：</strong></p><ul><li>range()方法，创建一个以<strong>1</strong>为增量步长，从startInclusive(包括)到endExclusive(不包括)的有序的数字流。</li><li>产生的IntStream对象，可以像数组一样遍历。</li></ul><p><strong>用法：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> IntStream <span class="title function_">range</span><span class="params">(<span class="type">int</span> startInclusive,<span class="type">int</span> endExclusive)</span>;</span><br></pre></td></tr></table></figure><p>参数</p><ul><li>IntStream : 原始整数值元素的序列</li><li>startInclusive : 规定了数字的起始值，包括</li><li>endExclusive : 规定了数字的上限值，不包括</li></ul><p>返回值</p><p>  一个int元素范围的顺序IntStream</p><p><strong>举例：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">RangeTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * Creating an IntStream:</span></span><br><span class="line"><span class="comment">         *    --including the lower bound but</span></span><br><span class="line"><span class="comment">         *    --excluding the upper bound</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="type">IntStream</span> <span class="variable">intStream</span> <span class="operator">=</span> IntStream.range(<span class="number">1</span>,<span class="number">5</span>);</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// Displaying the elements in range</span></span><br><span class="line">        intStream.forEach(System.out::println);</span><br><span class="line"> </span><br><span class="line">        <span class="comment">//上述代码简要写法</span></span><br><span class="line"><span class="comment">//      IntStream.range(1,5).forEach(i-&gt; System.out.println(i));//创建一个1-4的数字流,并打印</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>运行结果：</strong></p><p><img src="https://gitee.com/Button_mkns/picgo/raw/master/img/image-20231116092134128.png" alt="image-20231116092134128"></p><p><strong>扩展：</strong></p><p>如果想要数字是闭区间，可以使用 rangeClosed() 方法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">static IntStream rangeClosed(int startInclusive, int endInclusive)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 知识碎片 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>jsr303</title>
      <link href="/2023/11/07/%E4%BA%9A%E4%BF%A1%E5%AE%9E%E4%B9%A0/%E7%AC%AC%E4%B8%80%E6%9C%88/jsr303/"/>
      <url>/2023/11/07/%E4%BA%9A%E4%BF%A1%E5%AE%9E%E4%B9%A0/%E7%AC%AC%E4%B8%80%E6%9C%88/jsr303/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/><h1 id="jsr303常用注解"><a href="#jsr303常用注解" class="headerlink" title="jsr303常用注解"></a><strong>jsr303常用注解</strong></h1><p><img src="https://gitee.com/Button_mkns/picgo/raw/master/img/image-20231030111839085.png" alt="image-20231030111839085"></p><h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><p>Hibernate 中填充一部分</p><p><img src="https://gitee.com/Button_mkns/picgo/raw/master/img/image-20231030112210956.png" alt="image-20231030112210956"></p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><h4 id="依赖"><a href="#依赖" class="headerlink" title="依赖"></a>依赖</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- https://mvnrepository.com/artifact/org.hibernate.validator/hibernate-validator --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.hibernate.validator<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>hibernate-validator<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>6.0.16.Final<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="给要校验的javaBean上标注校验注解"><a href="#给要校验的javaBean上标注校验注解" class="headerlink" title="给要校验的javaBean上标注校验注解"></a>给要校验的javaBean上标注校验注解</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ToString</span></span><br><span class="line"><span class="meta">@Getter</span></span><br><span class="line"><span class="meta">@Setter</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UmsAdminParam</span> &#123;</span><br><span class="line">    <span class="comment">//规定长度</span></span><br><span class="line">    <span class="meta">@Length(min = 6, max = 19, message = &quot;用户名长度是6-18位&quot;)</span></span><br><span class="line">    <span class="meta">@ApiModelProperty(value = &quot;用户名&quot;, required = true)</span></span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line">    <span class="meta">@ApiModelProperty(value = &quot;密码&quot;, required = true)</span></span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line">    <span class="comment">//不能是空的</span></span><br><span class="line">    <span class="meta">@NotEmpty</span></span><br><span class="line">    <span class="meta">@ApiModelProperty(value = &quot;用户头像&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String icon;</span><br><span class="line">    <span class="meta">@Email(message = &quot;邮箱格式错误&quot;)</span></span><br><span class="line">    <span class="meta">@ApiModelProperty(value = &quot;邮箱&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String email;</span><br><span class="line">    <span class="meta">@NotNull</span></span><br><span class="line">    <span class="meta">@ApiModelProperty(value = &quot;用户昵称&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String nickName;</span><br><span class="line">    <span class="meta">@ApiModelProperty(value = &quot;备注&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String note;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="告诉spring这个数据需要校验-Valid同时在方法上添加-Validated"><a href="#告诉spring这个数据需要校验-Valid同时在方法上添加-Validated" class="headerlink" title="告诉spring这个数据需要校验@Valid同时在方法上添加@Validated"></a>告诉spring这个数据需要校验@Valid同时在方法上添加@Validated</h3><p>@Valid属于javax的 不抛异常</p><p>@Validated属于spring用AOP拦截会抛异常 </p><blockquote><p>推荐同时使用</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">    * 新增养修信息预约</span><br><span class="line">    */</span><br><span class="line">   @PreAuthorize(&quot;@ss.hasPermi(&#x27;appointment:info:add&#x27;)&quot;)</span><br><span class="line">   @Log(title = &quot;养修信息预约&quot;, businessType = BusinessType.INSERT)</span><br><span class="line">   @PostMapping</span><br><span class="line">   public AjaxResult add(@Validated @RequestBody BusAppointmentVo busAppointment)</span><br><span class="line">   &#123;</span><br><span class="line">       return toAjax(busAppointmentService.insertBusAppointment(busAppointment));</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/Button_mkns/picgo/raw/master/img/image-20231030112637441.png" alt="image-20231030112637441"></p><h3 id="感知校验成功-x2F-失败"><a href="#感知校验成功-x2F-失败" class="headerlink" title="感知校验成功&#x2F;失败"></a>感知校验成功&#x2F;失败</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">Stringregister</span><span class="params">(<span class="meta">@Valid</span> <span class="meta">@RequestBody</span> UmsAdminParam user,BindingResult result)</span> &#123;</span><br><span class="line">        <span class="comment">//得到所有错误信息计数</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">errorCount</span> <span class="operator">=</span> result.getErrorCount();</span><br><span class="line">        <span class="comment">//错误数大于0</span></span><br><span class="line">        <span class="keyword">if</span> (errorCount&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="comment">//得到所有错误</span></span><br><span class="line">            List&lt;FieldError&gt; fieldErrors = result.getFieldErrors();</span><br><span class="line">            <span class="comment">//迭代错误</span></span><br><span class="line">            fieldErrors.forEach((fieldError)-&gt;&#123;</span><br><span class="line">            <span class="comment">//错误信息</span></span><br><span class="line">                <span class="type">String</span> <span class="variable">field</span> <span class="operator">=</span> fieldError.getField();</span><br><span class="line">                log.debug(<span class="string">&quot;属性：&#123;&#125;,传来的值是：&#123;&#125;,出错的提示消息：&#123;&#125;&quot;</span>,</span><br><span class="line">                        field,fieldError.getRejectedValue(),fieldError.getDefaultMessage());</span><br><span class="line">            &#125;);</span><br><span class="line">            <span class="keyword">return</span> fieldError.getRejectedValue()+<span class="string">&quot;出错:&quot;</span>+fieldError.getDefaultMessage();</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">&quot;登录成功&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 亚信实习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java规范 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>easyExcel</title>
      <link href="/2023/10/25/%E4%BA%9A%E4%BF%A1%E5%AE%9E%E4%B9%A0/%E7%AC%AC%E4%B8%80%E6%9C%88/easyExcel/"/>
      <url>/2023/10/25/%E4%BA%9A%E4%BF%A1%E5%AE%9E%E4%B9%A0/%E7%AC%AC%E4%B8%80%E6%9C%88/easyExcel/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/>### 一、简介<p>EasyExcel是一个基于Java的简单、省内存的读写Excel的开源项目。在尽可能节约内存的情况下支持读写百M的Excel。</p><h3 id="二、详解读取Excel"><a href="#二、详解读取Excel" class="headerlink" title="二、详解读取Excel"></a>二、详解读取Excel</h3><h4 id="简单读取"><a href="#简单读取" class="headerlink" title="简单读取"></a>简单读取</h4><p><strong>对象</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如果没有特殊说明，下面的案例将默认使用这个实体类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DemoData</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String string;</span><br><span class="line">    <span class="keyword">private</span> Date date;</span><br><span class="line">    <span class="keyword">private</span> Double doubleData;</span><br><span class="line">    <span class="comment">// getting setting</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>监听器</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如果没有特殊说明，下面的案例将默认使用这个监听器</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DemoDataListener</span> <span class="keyword">extends</span> <span class="title class_">AnalysisEventListener</span>&lt;DemoData&gt; &#123;</span><br><span class="line"></span><br><span class="line">    List&lt;DemoData&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;DemoData&gt;();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 如果使用了spring,请使用这个构造方法。每次创建Listener的时候需要把spring管理的类传进来</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">DemoDataListener</span><span class="params">()</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 这个每一条数据解析都会来调用</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> data</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> context</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">invoke</span><span class="params">(DemoData data, AnalysisContext context)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;解析到一条数据:&#123;&#125;&quot;</span>, JSON.toJSONString(data));</span><br><span class="line">        list.add(data);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 所有数据解析完成了 都会来调用</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> context</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doAfterAllAnalysed</span><span class="params">(AnalysisContext context)</span> &#123;</span><br><span class="line">        System.out.println(JSON.toJSONString(list));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">simpleRead</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 写法1：</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">fileName</span> <span class="operator">=</span> <span class="string">&quot;demo.xlsx&quot;</span>;</span><br><span class="line">    <span class="comment">// 这里 需要指定读用哪个class去读，然后读取第一个sheet 文件流会自动关闭</span></span><br><span class="line">    EasyExcel.read(fileName, DemoData.class, <span class="keyword">new</span> <span class="title class_">DemoDataListener</span>()).sheet().doRead();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 写法2：</span></span><br><span class="line">    fileName = <span class="string">&quot;demo.xlsx&quot;</span>;</span><br><span class="line">    <span class="type">ExcelReader</span> <span class="variable">excelReader</span> <span class="operator">=</span> EasyExcel.read(fileName, DemoData.class, <span class="keyword">new</span> <span class="title class_">DemoDataListener</span>()).build();</span><br><span class="line">    <span class="type">ReadSheet</span> <span class="variable">readSheet</span> <span class="operator">=</span> EasyExcel.readSheet(<span class="number">0</span>).build();</span><br><span class="line">    excelReader.read(readSheet);</span><br><span class="line">    <span class="comment">// 这里千万别忘记关闭，读的时候会创建临时文件，到时磁盘会崩的</span></span><br><span class="line">    excelReader.finish();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="指定列的下标或名称"><a href="#指定列的下标或名称" class="headerlink" title="指定列的下标或名称"></a>指定列的下标或名称</h4><p><strong>对象</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DemoData</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 强制读取第三个 这里不建议 index 和 name 同时用，要么一个对象只用index，要么一个对象只用name去匹配</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@ExcelProperty(index = 2)</span></span><br><span class="line">    <span class="keyword">private</span> Double doubleData;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 用名字去匹配，这里需要注意，如果名字重复，会导致只有一个字段读取到数据</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@ExcelProperty(&quot;字符串标题&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String string;</span><br><span class="line">    <span class="meta">@ExcelProperty(&quot;日期标题&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> Date date;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="读取多个sheet"><a href="#读取多个sheet" class="headerlink" title="读取多个sheet"></a>读取多个sheet</h4><p><strong>代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">repeatedRead</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">fileName</span> <span class="operator">=</span> <span class="string">&quot;demo.xlsx&quot;</span>;</span><br><span class="line">    <span class="comment">// 读取全部sheet</span></span><br><span class="line">    <span class="comment">// 这里需要注意 DemoDataListener的doAfterAllAnalysed 会在每个sheet读取完毕后调用一次。然后所有sheet都会往同一个DemoDataListener里面写</span></span><br><span class="line">    EasyExcel.read(fileName, DemoData.class, <span class="keyword">new</span> <span class="title class_">DemoDataListener</span>()).doReadAll();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 读取部分sheet</span></span><br><span class="line">    fileName = <span class="string">&quot;demo.xlsx&quot;</span>;</span><br><span class="line">    <span class="type">ExcelReader</span> <span class="variable">excelReader</span> <span class="operator">=</span> EasyExcel.read(fileName).build();</span><br><span class="line">    <span class="comment">// 这里为了简单 所以注册了 同样的head 和Listener 自己使用功能必须不同的Listener</span></span><br><span class="line">    <span class="comment">// readSheet参数设置读取sheet的序号</span></span><br><span class="line">    <span class="type">ReadSheet</span> <span class="variable">readSheet1</span> <span class="operator">=</span></span><br><span class="line">        EasyExcel.readSheet(<span class="number">0</span>).head(DemoData.class).registerReadListener(<span class="keyword">new</span> <span class="title class_">DemoDataListener</span>()).build();</span><br><span class="line">    <span class="type">ReadSheet</span> <span class="variable">readSheet2</span> <span class="operator">=</span></span><br><span class="line">        EasyExcel.readSheet(<span class="number">1</span>).head(DemoData.class).registerReadListener(<span class="keyword">new</span> <span class="title class_">DemoDataListener</span>()).build();</span><br><span class="line">    <span class="comment">// 这里注意 一定要把sheet1 sheet2 一起传进去，不然有个问题就是03版的excel 会读取多次，浪费性能</span></span><br><span class="line">    excelReader.read(readSheet1, readSheet2);</span><br><span class="line">    <span class="comment">// 这里千万别忘记关闭，读的时候会创建临时文件，到时磁盘会崩的</span></span><br><span class="line">    excelReader.finish();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="自定义格式转换"><a href="#自定义格式转换" class="headerlink" title="自定义格式转换"></a>自定义格式转换</h4><p><strong>对象</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConverterData</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * converter属性定义自己的字符串转换器</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@ExcelProperty(converter = CustomStringConverter.class)</span></span><br><span class="line">    <span class="keyword">private</span> String string;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 这里用string 去接日期才能格式化</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@DateTimeFormat(&quot;yyyy年MM月dd日 HH时mm分ss秒&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String date;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 我想接收百分比的数字</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@NumberFormat(&quot;#.##%&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String doubleData;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">converterRead</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">fileName</span> <span class="operator">=</span> <span class="string">&quot;demo.xlsx&quot;</span>;</span><br><span class="line">    <span class="comment">// 这里 需要指定读用哪个class去读，然后读取第一个sheet </span></span><br><span class="line">    EasyExcel.read(fileName, ConverterData.class, <span class="keyword">new</span> <span class="title class_">ConverterDataListener</span>())</span><br><span class="line">        <span class="comment">// 这里注意 我们也可以registerConverter来指定自定义转换器， 但是这个转换变成全局了， 所有java为string,excel为string的都会用这个转换器。</span></span><br><span class="line">        <span class="comment">// 如果就想单个字段使用请使用@ExcelProperty 指定converter</span></span><br><span class="line">        <span class="comment">// .registerConverter(new CustomStringStringConverter())</span></span><br><span class="line">        <span class="comment">// 读取sheet</span></span><br><span class="line">        .sheet().doRead();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="多行头"><a href="#多行头" class="headerlink" title="多行头"></a>多行头</h4><p><strong>代码</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void complexHeaderRead() &#123;</span><br><span class="line">    String fileName = &quot;demo.xlsx&quot;;</span><br><span class="line">    // 这里 需要指定读用哪个class去读，然后读取第一个sheet </span><br><span class="line">    EasyExcel.read(fileName, DemoData.class, new DemoDataListener()).sheet()</span><br><span class="line">        // 这里可以设置1，因为头就是一行。如果多行头，可以设置其他值。不传入默认1行</span><br><span class="line">        .headRowNumber(1).doRead();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="读取表头数据"><a href="#读取表头数据" class="headerlink" title="读取表头数据"></a>读取表头数据</h4><p><strong>监听器</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 这里会一行行的返回头</span></span><br><span class="line"><span class="comment"> * 监听器只需要重写这个方法就可以读取到头信息</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> headMap</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> context</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">invokeHeadMap</span><span class="params">(Map&lt;Integer, String&gt; headMap, AnalysisContext context)</span> &#123;</span><br><span class="line">    LOGGER.info(<span class="string">&quot;解析到一条头数据:&#123;&#125;&quot;</span>, JSON.toJSONString(headMap));</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">headerRead</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">fileName</span> <span class="operator">=</span> <span class="string">&quot;demo.xlsx&quot;</span>;</span><br><span class="line">    <span class="comment">// 这里 需要指定读用哪个class去读，然后读取第一个sheet</span></span><br><span class="line">    EasyExcel.read(fileName, DemoData.class, <span class="keyword">new</span> <span class="title class_">ReadDataListener</span>()).sheet().doRead();</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">headerRead</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">fileName</span> <span class="operator">=</span> <span class="string">&quot;demo.xlsx&quot;</span>;</span><br><span class="line">    <span class="comment">// 这里 需要指定读用哪个class去读，然后读取第一个sheet</span></span><br><span class="line">    EasyExcel.read(fileName, DemoData.class, <span class="keyword">new</span> <span class="title class_">ReadDataListener</span>()).sheet().doRead();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h4><p><strong>监听器</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 监听器实现这个方法就可以在读取数据的时候获取到异常信息</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onException</span><span class="params">(Exception exception, AnalysisContext context)</span> &#123;</span><br><span class="line">    LOGGER.error(<span class="string">&quot;解析失败，但是继续解析下一行:&#123;&#125;&quot;</span>, exception.getMessage());</span><br><span class="line">    <span class="comment">// 如果是某一个单元格的转换异常 能获取到具体行号</span></span><br><span class="line">    <span class="comment">// 如果要获取头的信息 配合invokeHeadMap使用</span></span><br><span class="line">    <span class="keyword">if</span> (exception <span class="keyword">instanceof</span> ExcelDataConvertException) &#123;</span><br><span class="line">        <span class="type">ExcelDataConvertException</span> <span class="variable">excelDataConvertException</span> <span class="operator">=</span> (ExcelDataConvertException)exception;</span><br><span class="line">        LOGGER.error(<span class="string">&quot;第&#123;&#125;行，第&#123;&#125;列解析异常&quot;</span>, excelDataConvertException.getRowIndex(),</span><br><span class="line">            excelDataConvertException.getColumnIndex());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="web读取"><a href="#web读取" class="headerlink" title="web读取"></a>web读取</h4><p><strong>代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@PostMapping(&quot;upload&quot;)</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">upload</span><span class="params">(MultipartFile file)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    EasyExcel.read(file.getInputStream(), UploadData.class, <span class="keyword">new</span> <span class="title class_">UploadDataListener</span>(uploadDAO)).sheet().doRead();</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;SUCCESS&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="三、详解写入Excel"><a href="#三、详解写入Excel" class="headerlink" title="三、详解写入Excel"></a>三、详解写入Excel</h3><p><strong>数据写入公用方法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> List&lt;DemoData&gt; <span class="title function_">data</span><span class="params">()</span> &#123;</span><br><span class="line">    List&lt;DemoData&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;DemoData&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        <span class="type">DemoData</span> <span class="variable">data</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DemoData</span>();</span><br><span class="line">        data.setString(<span class="string">&quot;字符串&quot;</span> + i);</span><br><span class="line">        data.setDate(<span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">        data.setDoubleData(<span class="number">0.56</span>);</span><br><span class="line">        list.add(data);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> list;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="简单写入"><a href="#简单写入" class="headerlink" title="简单写入"></a>简单写入</h4><p><strong>对象</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DemoData</span> &#123;</span><br><span class="line">    <span class="meta">@ExcelProperty(&quot;字符串标题&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String string;</span><br><span class="line">    <span class="meta">@ExcelProperty(&quot;日期标题&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> Date date;</span><br><span class="line">    <span class="meta">@ExcelProperty(&quot;数字标题&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> Double doubleData;</span><br><span class="line">    <span class="comment">// getting setting</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">simpleWrite</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 写法1</span></span><br><span class="line">    String System.currentTimeMillis() + <span class="string">&quot;.xlsx&quot;</span>;</span><br><span class="line">    <span class="comment">// 这里 需要指定写用哪个class去写，然后写到第一个sheet，名字为模板 然后文件流会自动关闭</span></span><br><span class="line">    <span class="comment">// 如果这里想使用03 则 传入excelType参数即可</span></span><br><span class="line">    EasyExcel.write(fileName, DemoData.class).sheet(<span class="string">&quot;写入方法一&quot;</span>).doWrite(data());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 写法2，方法二需要手动关闭流</span></span><br><span class="line">    fileName = System.currentTimeMillis() + <span class="string">&quot;.xlsx&quot;</span>;</span><br><span class="line">    <span class="comment">// 这里 需要指定写用哪个class去写</span></span><br><span class="line">    <span class="type">ExcelWriter</span> <span class="variable">excelWriter</span> <span class="operator">=</span> EasyExcel.write(fileName, DemoData.class).build();</span><br><span class="line">    <span class="type">WriteSheet</span> <span class="variable">writeSheet</span> <span class="operator">=</span> EasyExcel.writerSheet(<span class="string">&quot;写入方法二&quot;</span>).build();</span><br><span class="line">    excelWriter.write(data(), writeSheet);</span><br><span class="line">    <span class="comment">/// 千万别忘记finish 会帮忙关闭流</span></span><br><span class="line">    excelWriter.finish();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="导出指定的列"><a href="#导出指定的列" class="headerlink" title="导出指定的列"></a>导出指定的列</h4><p><strong>代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">excludeOrIncludeWrite</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">fileName</span> <span class="operator">=</span> <span class="string">&quot;excludeOrIncludeWrite&quot;</span> + System.currentTimeMillis() + <span class="string">&quot;.xlsx&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 忽略 date 不导出</span></span><br><span class="line">    Set&lt;String&gt; excludeColumnFiledNames = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;String&gt;();</span><br><span class="line">    excludeColumnFiledNames.add(<span class="string">&quot;date&quot;</span>);</span><br><span class="line">    <span class="comment">// 这里 需要指定写用哪个class去写，然后写到第一个sheet，名字为模板 然后文件流会自动关闭</span></span><br><span class="line">    EasyExcel.write(fileName, DemoData.class).excludeColumnFiledNames(excludeColumnFiledNames).sheet(<span class="string">&quot;忽略date&quot;</span>)</span><br><span class="line">        .doWrite(data());</span><br><span class="line"></span><br><span class="line">    fileName = <span class="string">&quot;excludeOrIncludeWrite&quot;</span> + System.currentTimeMillis() + <span class="string">&quot;.xlsx&quot;</span>;</span><br><span class="line">    <span class="comment">// 根据用户传入字段 假设我们只要导出 date</span></span><br><span class="line">    Set&lt;String&gt; includeColumnFiledNames = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;String&gt;();</span><br><span class="line">    includeColumnFiledNames.add(<span class="string">&quot;date&quot;</span>);</span><br><span class="line">    <span class="comment">// 这里 需要指定写用哪个class去写，然后写到第一个sheet，名字为模板 然后文件流会自动关闭</span></span><br><span class="line">    EasyExcel.write(fileName, DemoData.class).includeColumnFiledNames(includeColumnFiledNames).sheet(<span class="string">&quot;导出date&quot;</span>)</span><br><span class="line">        .doWrite(data());</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="指定写入的列"><a href="#指定写入的列" class="headerlink" title="指定写入的列"></a>指定写入的列</h4><p><strong>对象</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">IndexData</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 导出的excel第二列和第四列将空置</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="meta">@ExcelProperty(value = &quot;字符串标题&quot;, index = 0)</span></span><br><span class="line">    <span class="keyword">private</span> String string;</span><br><span class="line">    <span class="meta">@ExcelProperty(value = &quot;日期标题&quot;, index = 2)</span></span><br><span class="line">    <span class="keyword">private</span> Date date;</span><br><span class="line">    <span class="meta">@ExcelProperty(value = &quot;数字标题&quot;, index = 4)</span></span><br><span class="line">    <span class="keyword">private</span> Double doubleData;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">indexWrite</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">fileName</span> <span class="operator">=</span> <span class="string">&quot;indexWrite&quot;</span> + System.currentTimeMillis() + <span class="string">&quot;.xlsx&quot;</span>;</span><br><span class="line">    <span class="comment">// 这里 需要指定写用哪个class去写，然后写到第一个sheet，名字为模板 然后文件流会自动关闭</span></span><br><span class="line">    EasyExcel.write(fileName, IndexData.class).sheet(<span class="string">&quot;模板&quot;</span>).doWrite(data());</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="复杂头写入"><a href="#复杂头写入" class="headerlink" title="复杂头写入"></a>复杂头写入</h4><p><strong>对象</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ComplexHeadData</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 主标题 将整合为一个单元格效果如下：</span></span><br><span class="line"><span class="comment">    * —————————————————————————</span></span><br><span class="line"><span class="comment">    * |          主标题        |</span></span><br><span class="line"><span class="comment">    * —————————————————————————</span></span><br><span class="line"><span class="comment">    * |字符串标题|日期标题|数字标题|</span></span><br><span class="line"><span class="comment">    * —————————————————————————</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="meta">@ExcelProperty(&#123;&quot;主标题&quot;, &quot;字符串标题&quot;&#125;)</span></span><br><span class="line">    <span class="keyword">private</span> String string;</span><br><span class="line">    <span class="meta">@ExcelProperty(&#123;&quot;主标题&quot;, &quot;日期标题&quot;&#125;)</span></span><br><span class="line">    <span class="keyword">private</span> Date date;</span><br><span class="line">    <span class="meta">@ExcelProperty(&#123;&quot;主标题&quot;, &quot;数字标题&quot;&#125;)</span></span><br><span class="line">    <span class="keyword">private</span> Double doubleData;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">complexHeadWrite</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">fileName</span> <span class="operator">=</span> <span class="string">&quot;complexHeadWrite&quot;</span> + System.currentTimeMillis() + <span class="string">&quot;.xlsx&quot;</span>;</span><br><span class="line">    <span class="comment">// 这里 需要指定写用哪个class去写，然后写到第一个sheet，名字为模板 然后文件流会自动关闭</span></span><br><span class="line">    EasyExcel.write(fileName, ComplexHeadData.class).sheet(<span class="string">&quot;模板&quot;</span>).doWrite(data());</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="自定义格式转换-1"><a href="#自定义格式转换-1" class="headerlink" title="自定义格式转换"></a>自定义格式转换</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConverterData</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 自定义的转换</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@ExcelProperty(value = &quot;字符串标题&quot;, converter = CustomStringConverter.class)</span></span><br><span class="line">    <span class="keyword">private</span> String string;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 我想写到excel 用年月日的格式</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@DateTimeFormat(&quot;yyyy年MM月dd日 HH时mm分ss秒&quot;)</span></span><br><span class="line">    <span class="meta">@ExcelProperty(&quot;日期标题&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> Date date;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 我想写到excel 用百分比表示</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@NumberFormat(&quot;#.##%&quot;)</span></span><br><span class="line">    <span class="meta">@ExcelProperty(value = &quot;数字标题&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> Double doubleData;</span><br><span class="line">    <span class="comment">// getting setting</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">converterWrite</span><span class="params">()</span> &#123;</span><br><span class="line">    String <span class="string">&quot;converterWrite&quot;</span> + System.currentTimeMillis() + <span class="string">&quot;.xlsx&quot;</span>;</span><br><span class="line">    <span class="comment">// 这里 需要指定写用哪个class去写，然后写到第一个sheet，名字为模板 然后文件流会自动关闭</span></span><br><span class="line">    EasyExcel.write(fileName, ConverterData.class).sheet(<span class="string">&quot;模板&quot;</span>).doWrite(data());</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="图片导出"><a href="#图片导出" class="headerlink" title="图片导出"></a>图片导出</h4><p><strong>对象</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@ContentRowHeight(200)</span></span><br><span class="line"><span class="meta">@ColumnWidth(200 / 8)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ImageData</span> &#123;</span><br><span class="line">    <span class="comment">// 图片导出方式有5种</span></span><br><span class="line">    <span class="keyword">private</span> File file;</span><br><span class="line">    <span class="keyword">private</span> InputStream inputStream;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 如果string类型 必须指定转换器，string默认转换成string，该转换器是官方支持的</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@ExcelProperty(converter = StringImageConverter.class)</span></span><br><span class="line">    <span class="keyword">private</span> String string;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">byte</span>[] byteArray;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据url导出 版本2.1.1才支持该种模式</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> URL url;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">imageWrite</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">fileName</span> <span class="operator">=</span> <span class="string">&quot;imageWrite&quot;</span> + System.currentTimeMillis() + <span class="string">&quot;.xlsx&quot;</span>;</span><br><span class="line">    <span class="comment">// 如果使用流 记得关闭</span></span><br><span class="line">    <span class="type">InputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        List&lt;ImageData&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;ImageData&gt;();</span><br><span class="line">        <span class="type">ImageData</span> <span class="variable">imageData</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ImageData</span>();</span><br><span class="line">        list.add(imageData);</span><br><span class="line">        <span class="type">String</span> <span class="variable">imagePath</span> <span class="operator">=</span> <span class="string">&quot;converter&quot;</span> + File.separator + <span class="string">&quot;img.jpg&quot;</span>;</span><br><span class="line">        <span class="comment">// 放入五种类型的图片 根据实际使用只要选一种即可</span></span><br><span class="line">        imageData.setByteArray(FileUtils.readFileToByteArray(<span class="keyword">new</span> <span class="title class_">File</span>(imagePath)));</span><br><span class="line">        imageData.setFile(<span class="keyword">new</span> <span class="title class_">File</span>(imagePath));</span><br><span class="line">        imageData.setString(imagePath);</span><br><span class="line">        inputStream = FileUtils.openInputStream(<span class="keyword">new</span> <span class="title class_">File</span>(imagePath));</span><br><span class="line">        imageData.setInputStream(inputStream);</span><br><span class="line">        imageData.setUrl(<span class="keyword">new</span> <span class="title class_">URL</span>(</span><br><span class="line">            <span class="string">&quot;https://raw.githubusercontent.com/alibaba/easyexcel/master/src/test/resources/converter/img.jpg&quot;</span>));</span><br><span class="line">        EasyExcel.write(fileName, ImageData.class).sheet().doWrite(list);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (inputStream != <span class="literal">null</span>) &#123;</span><br><span class="line">            inputStream.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="列宽、行高"><a href="#列宽、行高" class="headerlink" title="列宽、行高"></a>列宽、行高</h4><p><strong>对象</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@ContentRowHeight(10)</span></span><br><span class="line"><span class="meta">@HeadRowHeight(20)</span></span><br><span class="line"><span class="meta">@ColumnWidth(25)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WidthAndHeightData</span> &#123;</span><br><span class="line">    <span class="meta">@ExcelProperty(&quot;字符串标题&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String string;</span><br><span class="line">    <span class="meta">@ExcelProperty(&quot;日期标题&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> Date date;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 宽度为50,覆盖上面的宽度25</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@ColumnWidth(50)</span></span><br><span class="line">    <span class="meta">@ExcelProperty(&quot;数字标题&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> Double doubleData;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">widthAndHeightWrite</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">fileName</span> <span class="operator">=</span> <span class="string">&quot;widthAndHeightWrite&quot;</span> + System.currentTimeMillis() + <span class="string">&quot;.xlsx&quot;</span>;</span><br><span class="line">    <span class="comment">// 这里 需要指定写用哪个class去写，然后写到第一个sheet，名字为模板 然后文件流会自动关闭</span></span><br><span class="line">    EasyExcel.write(fileName, WidthAndHeightData.class).sheet(<span class="string">&quot;模板&quot;</span>).doWrite(data());</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="合并单元格"><a href="#合并单元格" class="headerlink" title="合并单元格"></a>合并单元格</h4><p><strong>代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">mergeWrite</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">fileName</span> <span class="operator">=</span> <span class="string">&quot;mergeWrite&quot;</span> + System.currentTimeMillis() + <span class="string">&quot;.xlsx&quot;</span>;</span><br><span class="line">    <span class="comment">// 每隔2行会合并 把eachColumn 设置成 3 也就是我们数据的长度，所以就第一列会合并。当然其他合并策略也可以自己写</span></span><br><span class="line">    <span class="type">LoopMergeStrategy</span> <span class="variable">loopMergeStrategy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LoopMergeStrategy</span>(<span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">// 这里 需要指定写用哪个class去写，然后写到第一个sheet，名字为模板 然后文件流会自动关闭</span></span><br><span class="line">    EasyExcel.write(fileName, DemoData.class).registerWriteHandler(loopMergeStrategy).sheet(<span class="string">&quot;合并单元格&quot;</span>)</span><br><span class="line">        .doWrite(data());</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="动态表头"><a href="#动态表头" class="headerlink" title="动态表头"></a>动态表头</h4><p><strong>代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dynamicHeadWrite</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">fileName</span> <span class="operator">=</span> <span class="string">&quot;dynamicHeadWrite&quot;</span> + System.currentTimeMillis() + <span class="string">&quot;.xlsx&quot;</span>;</span><br><span class="line">    EasyExcel.write(fileName)</span><br><span class="line">        <span class="comment">// 这里放入动态头</span></span><br><span class="line">        .head(head()).sheet(<span class="string">&quot;模板&quot;</span>)</span><br><span class="line">        <span class="comment">// 当然这里数据也可以用 List&lt;List&lt;String&gt;&gt; 去传入</span></span><br><span class="line">        .doWrite(data());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 动态表头的数据格式List&lt;List&lt;String&gt;&gt;</span></span><br><span class="line"><span class="keyword">private</span> List&lt;List&lt;String&gt;&gt; <span class="title function_">head</span><span class="params">()</span> &#123;</span><br><span class="line">    List&lt;List&lt;String&gt;&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;List&lt;String&gt;&gt;();</span><br><span class="line">    List&lt;String&gt; head0 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();</span><br><span class="line">    head0.add(<span class="string">&quot;字符串&quot;</span> + System.currentTimeMillis());</span><br><span class="line">    List&lt;String&gt; head1 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();</span><br><span class="line">    head1.add(<span class="string">&quot;数字&quot;</span> + System.currentTimeMillis());</span><br><span class="line">    List&lt;String&gt; head2 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();</span><br><span class="line">    head2.add(<span class="string">&quot;日期&quot;</span> + System.currentTimeMillis());</span><br><span class="line">    list.add(head0);</span><br><span class="line">    list.add(head1);</span><br><span class="line">    list.add(head2);</span><br><span class="line">    <span class="keyword">return</span> list;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="web数据写出"><a href="#web数据写出" class="headerlink" title="web数据写出"></a>web数据写出</h4><p><strong>代码</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@GetMapping(&quot;download&quot;)</span><br><span class="line">public void download(HttpServletResponse response) throws IOException &#123;</span><br><span class="line">    response.setContentType(&quot;application/vnd.ms-excel&quot;);</span><br><span class="line">    response.setCharacterEncoding(&quot;utf-8&quot;);</span><br><span class="line">    // 这里URLEncoder.encode可以防止中文乱码 当然和easyexcel没有关系</span><br><span class="line">    String fileName = URLEncoder.encode(&quot;数据写出&quot;, &quot;UTF-8&quot;);</span><br><span class="line">    response.setHeader(&quot;Content-disposition&quot;, &quot;attachment;filename=&quot; + fileName + &quot;.xlsx&quot;);</span><br><span class="line">    EasyExcel.write(response.getOutputStream(), DownloadData.class).sheet(&quot;模板&quot;).doWrite(data());</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="四、详解填充样板写入"><a href="#四、详解填充样板写入" class="headerlink" title="四、详解填充样板写入"></a>四、详解填充样板写入</h3><h4 id="简单的填充"><a href="#简单的填充" class="headerlink" title="简单的填充"></a>简单的填充</h4><p><strong>Excel模板</strong><br><img src="F:/%E4%BA%9A%E4%BF%A1%E5%AE%9E%E4%B9%A0/9%E6%9C%88/%E7%AC%AC%E4%B8%89%E5%91%A8day17/easyExcel.assets/image-20231026160351202.png" alt="image-20231026160351202"></p><p><strong>Excel最终效果</strong></p><p><img src="F:/%E4%BA%9A%E4%BF%A1%E5%AE%9E%E4%B9%A0/9%E6%9C%88/%E7%AC%AC%E4%B8%89%E5%91%A8day17/easyExcel.assets/image-20231026160406791.png" alt="image-20231026160406791"></p><p><strong>对象</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FillData</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">double</span> number;</span><br><span class="line">    <span class="comment">// getting setting</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">simpleFill</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 模板注意 用&#123;&#125; 来表示你要用的变量 如果本来就有&quot;&#123;&quot;,&quot;&#125;&quot; 特殊字符 用&quot;\&#123;&quot;,&quot;\&#125;&quot;代替</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">templateFileName</span> <span class="operator">=</span> <span class="string">&quot;simple.xlsx&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 方案1 根据对象填充</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">fileName</span> <span class="operator">=</span> System.currentTimeMillis() + <span class="string">&quot;.xlsx&quot;</span>;</span><br><span class="line">    <span class="comment">// 这里 会填充到第一个sheet， 然后文件流会自动关闭</span></span><br><span class="line">    <span class="type">FillData</span> <span class="variable">fillData</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FillData</span>();</span><br><span class="line">    fillData.setName(<span class="string">&quot;知春秋&quot;</span>);</span><br><span class="line">    fillData.setNumber(<span class="number">25</span>);</span><br><span class="line">    EasyExcel.write(fileName).withTemplate(templateFileName).sheet().doFill(fillData);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 方案2 根据Map填充</span></span><br><span class="line">    fileName = System.currentTimeMillis() + <span class="string">&quot;.xlsx&quot;</span>;</span><br><span class="line">    <span class="comment">// 这里 会填充到第一个sheet， 然后文件流会自动关闭</span></span><br><span class="line">    Map&lt;String, Object&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String, Object&gt;();</span><br><span class="line">    map.put(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;知春秋&quot;</span>);</span><br><span class="line">    map.put(<span class="string">&quot;number&quot;</span>, <span class="number">25</span>);</span><br><span class="line">    EasyExcel.write(fileName).withTemplate(templateFileName).sheet().doFill(map);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="复杂的填充"><a href="#复杂的填充" class="headerlink" title="复杂的填充"></a>复杂的填充</h4><p>使用List集合的方法批量写入数据，点表示该参数是集合</p><p><strong>Excel模板</strong></p><p><img src="F:/%E4%BA%9A%E4%BF%A1%E5%AE%9E%E4%B9%A0/9%E6%9C%88/%E7%AC%AC%E4%B8%89%E5%91%A8day17/easyExcel.assets/image-20231026160452548.png" alt="image-20231026160452548"></p><p><strong>Excel最终效果</strong></p><p><img src="F:/%E4%BA%9A%E4%BF%A1%E5%AE%9E%E4%B9%A0/9%E6%9C%88/%E7%AC%AC%E4%B8%89%E5%91%A8day17/easyExcel.assets/image-20231026160506051.png" alt="image-20231026160506051"></p><p><strong>代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">complexFill</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 模板注意 用&#123;&#125; 来表示你要用的变量 如果本来就有&quot;&#123;&quot;,&quot;&#125;&quot; 特殊字符 用&quot;\&#123;&quot;,&quot;\&#125;&quot;代替</span></span><br><span class="line">    <span class="comment">// &#123;&#125; 代表普通变量 &#123;.&#125; 代表是list的变量</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">templateFileName</span> <span class="operator">=</span> <span class="string">&quot;complex.xlsx&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">String</span> <span class="variable">fileName</span> <span class="operator">=</span> System.currentTimeMillis() + <span class="string">&quot;.xlsx&quot;</span>;</span><br><span class="line">    <span class="type">ExcelWriter</span> <span class="variable">excelWriter</span> <span class="operator">=</span> EasyExcel.write(fileName).withTemplate(templateFileName).build();</span><br><span class="line">    <span class="type">WriteSheet</span> <span class="variable">writeSheet</span> <span class="operator">=</span> EasyExcel.writerSheet().build();</span><br><span class="line">    <span class="comment">// 这里注意 入参用了forceNewRow 代表在写入list的时候不管list下面有没有空行 都会创建一行，然后下面的数据往后移动。默认 是false，会直接使用下一行，如果没有则创建。</span></span><br><span class="line">    <span class="comment">// forceNewRow 如果设置了true,有个缺点 就是他会把所有的数据都放到内存了，所以慎用</span></span><br><span class="line">    <span class="comment">// 简单的说 如果你的模板有list,且list不是最后一行，下面还有数据需要填充 就必须设置 forceNewRow=true 但是这个就会把所有数据放到内存 会很耗内存</span></span><br><span class="line">    <span class="comment">// 如果数据量大 list不是最后一行 参照下一个</span></span><br><span class="line">    <span class="type">FillConfig</span> <span class="variable">fillConfig</span> <span class="operator">=</span> FillConfig.builder().forceNewRow(Boolean.TRUE).build();</span><br><span class="line">    excelWriter.fill(data(), fillConfig, writeSheet);</span><br><span class="line">    excelWriter.fill(data(), fillConfig, writeSheet);</span><br><span class="line">    <span class="comment">// 其他参数可以使用Map封装</span></span><br><span class="line">    Map&lt;String, Object&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String, Object&gt;();</span><br><span class="line">    excelWriter.fill(map, writeSheet);</span><br><span class="line">    excelWriter.finish();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="五、API"><a href="#五、API" class="headerlink" title="五、API"></a>五、API</h3><p>详细参数介绍<br>关于常见类解析</p><p>Ø EasyExcel 入口类，用于构建开始各种操作</p><p>Ø ExcelReaderBuilder ExcelWriterBuilder 构建出一个 ReadWorkbook WriteWorkbook，可以理解成一个excel对象，一个excel只要构建一个</p><p>Ø ExcelReaderSheetBuilder ExcelWriterSheetBuilder 构建出一个 ReadSheet WriteSheet对象，可以理解成excel里面的一页,每一页都要构建一个</p><p>Ø ReadListener 在每一行读取完毕后都会调用ReadListener来处理数据</p><p>Ø WriteHandler 在每一个操作包括创建单元格、创建表格等都会调用WriteHandler来处理数据</p><p>Ø 所有配置都是继承的，Workbook的配置会被Sheet继承，所以在用EasyExcel设置参数的时候，在EasyExcel…sheet()方法之前作用域是整个sheet,之后针对单个sheet<br>读<br>注解</p><p>Ø ExcelProperty 指定当前字段对应excel中的那一列。可以根据名字或者Index去匹配。当然也可以不写，默认第一个字段就是index&#x3D;0，以此类推。千万注意，要么全部不写，要么全部用index，要么全部用名字去匹配。千万别三个混着用，除非你非常了解源代码中三个混着用怎么去排序的。</p><p>Ø ExcelIgnore 默认所有字段都会和excel去匹配，加了这个注解会忽略该字段</p><p>Ø DateTimeFormat 日期转换，用String去接收excel日期格式的数据会调用这个注解。里面的value参照java.text.SimpleDateFormat</p><p>Ø NumberFormat 数字转换，用String去接收excel数字格式的数据会调用这个注解。里面的value参照java.text.DecimalFormat</p><p>Ø ExcelIgnoreUnannotated 默认不加ExcelProperty 的注解的都会参与读写，加了不会参与<br>参数<br>通用参数</p><p>Ø ReadWorkbook,ReadSheet 都会有的参数，如果为空，默认使用上级。</p><p>Ø converter 转换器，默认加载了很多转换器。也可以自定义。</p><p>Ø readListener 监听器，在读取数据的过程中会不断的调用监听器。</p><p>Ø headRowNumber 需要读的表格有几行头数据。默认有一行头，也就是认为第二行开始起为数据。</p><p>Ø head 与clazz二选一。读取文件头对应的列表，会根据列表匹配数据，建议使用class。</p><p>Ø clazz 与head二选一。读取文件的头对应的class，也可以使用注解。如果两个都不指定，则会读取全部数据。</p><p>Ø autoTrim 字符串、表头等数据自动trim</p><p>Ø password 读的时候是否需要使用密码<br>ReadWorkbook（理解成excel对象）参数</p><p>Ø excelType 当前excel的类型 默认会自动判断</p><p>Ø inputStream 与file二选一。读取文件的流，如果接收到的是流就只用，不用流建议使用file参数。因为使用了inputStream easyexcel会帮忙创建临时文件，最终还是file</p><p>Ø file 与inputStream二选一。读取文件的文件。</p><p>Ø autoCloseStream 自动关闭流。</p><p>Ø readCache 默认小于5M用 内存，超过5M会使用 EhCache,这里不建议使用这个参数。<br>ReadSheet（就是excel的一个Sheet）参数</p><p>Ø sheetNo 需要读取Sheet的编码，建议使用这个来指定读取哪个Sheet</p><p>Ø sheetName 根据名字去匹配Sheet,excel 2003不支持根据名字去匹配<br>写<br>注解</p><p>Ø ExcelProperty index 指定写到第几列，默认根据成员变量排序。value指定写入的名称，默认成员变量的名字，多个value可以参照快速开始中的复杂头</p><p>Ø ExcelIgnore 默认所有字段都会写入excel，这个注解会忽略这个字段</p><p>Ø DateTimeFormat 日期转换，将Date写到excel会调用这个注解。里面的value参照java.text.SimpleDateFormat</p><p>Ø NumberFormat 数字转换，用Number写excel会调用这个注解。里面的value参照java.text.DecimalFormat</p><p>Ø ExcelIgnoreUnannotated 默认不加ExcelProperty 的注解的都会参与读写，加了不会参与<br>参数<br>通用参数</p><p>Ø WriteWorkbook,WriteSheet ,WriteTable都会有的参数，如果为空，默认使用上级。</p><p>Ø converter 转换器，默认加载了很多转换器。也可以自定义。</p><p>Ø writeHandler 写的处理器。可以实现WorkbookWriteHandler,SheetWriteHandler,RowWriteHandler,CellWriteHandler，在写入excel的不同阶段会调用</p><p>Ø relativeHeadRowIndex 距离多少行后开始。也就是开头空几行</p><p>Ø needHead 是否导出头</p><p>Ø head 与clazz二选一。写入文件的头列表，建议使用class。</p><p>Ø clazz 与head二选一。写入文件的头对应的class，也可以使用注解。</p><p>Ø autoTrim 字符串、表头等数据自动trim<br>WriteWorkbook（理解成excel对象）参数</p><p>Ø excelType 当前excel的类型 默认xlsx</p><p>Ø outputStream 与file二选一。写入文件的流</p><p>Ø file 与outputStream二选一。写入的文件</p><p>Ø templateInputStream 模板的文件流</p><p>Ø templateFile 模板文件</p><p>Ø autoCloseStream 自动关闭流。</p><p>Ø password 写的时候是否需要使用密码</p><p>Ø useDefaultStyle 写的时候是否是使用默认头<br>WriteSheet（就是excel的一个Sheet）参数</p><p>Ø sheetNo 需要写入的编码。默认0</p><p>Ø sheetName 需要些的Sheet名称，默认同sheetNo<br>WriteTable（就把excel的一个Sheet,一块区域看一个table）参数</p><p>Ø tableNo 需要写入的编码。默认0</p>]]></content>
      
      
      <categories>
          
          <category> 亚信实习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 第三方API </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>线程池</title>
      <link href="/2023/10/18/%E4%BA%9A%E4%BF%A1%E5%AE%9E%E4%B9%A0/%E7%AC%AC%E4%B8%80%E6%9C%88/%E7%AC%AC%E4%B8%89%E5%91%A8day14/%E7%BA%BF%E7%A8%8B%E6%B1%A0/"/>
      <url>/2023/10/18/%E4%BA%9A%E4%BF%A1%E5%AE%9E%E4%B9%A0/%E7%AC%AC%E4%B8%80%E6%9C%88/%E7%AC%AC%E4%B8%89%E5%91%A8day14/%E7%BA%BF%E7%A8%8B%E6%B1%A0/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/><p><strong>线程池的创建</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义线程池</span></span><br><span class="line">        <span class="type">ThreadPoolExecutor</span> <span class="variable">pool</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(</span><br><span class="line">                <span class="number">8</span>,<span class="comment">//核心线程数</span></span><br><span class="line">                <span class="number">15</span>,<span class="comment">//最大线程数</span></span><br><span class="line">                <span class="number">60</span>,<span class="comment">//空闲线程最大存活时间按</span></span><br><span class="line">                TimeUnit.SECONDS,<span class="comment">//时间单位</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">ArrayBlockingQueue</span>&lt;&gt;(<span class="number">10</span>),<span class="comment">//任务队列</span></span><br><span class="line">                Executors.defaultThreadFactory(),<span class="comment">//创建线程工厂</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>.AbortPolicy()<span class="comment">//任务的拒绝策略</span></span><br><span class="line">        );</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">for</span> (Object o : m) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">stationId</span> <span class="operator">=</span> orgStationEntity.getStationId();</span><br><span class="line">            <span class="type">ReportQueryParamVo</span> <span class="variable">stationParam</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReportQueryParamVo</span>();</span><br><span class="line">         </span><br><span class="line">            aaa.setS(stationId);</span><br><span class="line">            aaa.setA(paramVo.getA());</span><br><span class="line">            aaa.setL(paramVo.getL());</span><br><span class="line">            aaa.setM(paramVo.getM());</span><br><span class="line">            aaa.setT(paramVo.getT());</span><br><span class="line">            aaa.setT(paramVo.getT());</span><br><span class="line"><span class="comment">//            lists.addAll(xxx(aaa));</span></span><br><span class="line">            pool.execute(() -&gt; lists.addAll(xxx(aaa)));</span><br><span class="line">        &#125;</span><br><span class="line">        pool.shutdown();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            pool.awaitTermination(Long.MAX_VALUE, TimeUnit.NANOSECONDS);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="comment">//用于堵塞线程 必须执行完以上线程才可以继续执行下面代码</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 亚信实习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JAVA基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>线程</title>
      <link href="/2023/10/16/%E4%BA%9A%E4%BF%A1%E5%AE%9E%E4%B9%A0/%E7%AC%AC%E4%B8%80%E6%9C%88/day12/"/>
      <url>/2023/10/16/%E4%BA%9A%E4%BF%A1%E5%AE%9E%E4%B9%A0/%E7%AC%AC%E4%B8%80%E6%9C%88/day12/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/># 线程<p><strong>1.多线程</strong></p><p><strong>1.1并行与并发</strong></p><ul><li><strong>并发</strong>：指两个或多个事件在<strong>同⼀个时间段内</strong>发⽣。 </li><li><strong>并⾏</strong>：指两个或多个事件在<strong>同⼀时刻</strong>发⽣（同时发⽣）。</li></ul><p><img src="https://gitee.com/Button_mkns/picgo/raw/master/img/image-20231016111951986.png" alt="image-20231016111951986"></p><blockquote><p>在操作系统中，安装了多个程序，并发指的是在⼀段时间内宏观上有多个程序同时运⾏，这在单 CPU 系统中，每⼀时刻只能有⼀道程序执⾏，即微观上这些程序是分时的交替运⾏，只不过是给⼈的感觉是同时运 ⾏，那是因为分时交替运⾏的时间是⾮常短的。<br>⽽在多个 CPU 系统中，则这些可以并发执⾏的程序便可以分配到多个处理器上（ CPU ），实现多任务并⾏ 执⾏，即利⽤每个处理器来处理⼀个可以并发执⾏的程序，这样多个程序便可以同时执⾏。⽬前电脑市场 上说的多核 CPU ，便是多核处理器，核 越多，并⾏处理的程序越多，能⼤⼤的提⾼电脑运⾏的效率。</p></blockquote><p><strong>1.2 线程与进程</strong></p><ul><li>进程：是指⼀个内存中运⾏的应⽤程序，每个进程都有⼀个独⽴的内存空间，⼀个应⽤程序可以同时运⾏多个进程；进程也是程序的⼀次执⾏过程，是系统运⾏程序的基本单位；系统运⾏⼀个程序即是 ⼀个进程从创建、运⾏到消亡的过程。</li><li>线程：线程是进程中的⼀个执⾏单元，负责当前进程中程序的执⾏，⼀个进程中⾄少有⼀个线程。⼀个进程中是可以有多个线程的，这个应⽤程序也可以称之为多线程程序。</li></ul><p><strong>1.3</strong> <strong>创建线程类</strong></p><p>Java 使⽤ java.lang.Thread 类代表 <strong>线程</strong> ，所有的线程对象都必须是 Thread 类或其⼦类的实例。每个线程的作⽤是完成⼀定的任务，实际上就是执⾏⼀段程序流即⼀段顺序执⾏的代码。 Java 使⽤线程执⾏体来 代表这段程序流。 Java 中通过继承 Thread 类来 <strong>创建</strong> 并 启动多线程 的步骤如下：</p><ol><li>定义 Thread 类的⼦类，并重写该类的 run() ⽅法，该 run() ⽅法的⽅法体就代表了线程需要完成的任务，因此把 run() ⽅法称为线程执⾏体。</li><li>创建 Thread ⼦类的实例，即创建了线程对象</li><li>调⽤线程对象的 start() ⽅法来启动该线程：</li></ol><p>  代码如下：  </p><p>  测试类： </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo01</span> &#123;</span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"> <span class="comment">// 创建⾃定义线程对象</span></span><br><span class="line"> <span class="type">MyThread</span> <span class="variable">mt</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread</span>(<span class="string">&quot;新的线程！&quot;</span>);</span><br><span class="line"> <span class="comment">// 开启新线程</span></span><br><span class="line"> mt.start();</span><br><span class="line"> <span class="comment">// 在主⽅法中执⾏for循环</span></span><br><span class="line"> <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line"> System.out.println(<span class="string">&quot;main线程！&quot;</span> + i);</span><br><span class="line"> &#125;</span><br><span class="line"> &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>⾃定义线程类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line"> <span class="comment">// 定义指定线程名称的构造⽅法</span></span><br><span class="line"> <span class="keyword">public</span> <span class="title function_">MyThread</span><span class="params">(String name)</span> &#123;</span><br><span class="line"> <span class="comment">// 调⽤⽗类的String参数的构造⽅法，指定线程的名称</span></span><br><span class="line"> <span class="built_in">super</span>(name);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 重写run⽅法，完成该线程执⾏的逻辑</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> <span class="meta">@Override</span></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line"> <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line"> System.out.println(getName() + <span class="string">&quot;：正在执⾏！&quot;</span> + i);</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-多线程详解"><a href="#2-多线程详解" class="headerlink" title="2 多线程详解"></a>2 <strong>多线程详解</strong></h2><h3 id="2-1-多线程原理"><a href="#2-1-多线程原理" class="headerlink" title="2.1 多线程原理"></a>2.1 <strong>多线程原理</strong></h3><p>⾃定义线程类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line"> <span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 利⽤继承中的特点</span></span><br><span class="line"><span class="comment"> * 将线程名称传递 进⾏设置</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> <span class="keyword">public</span> <span class="title function_">MyThread</span><span class="params">(String name)</span> &#123;</span><br><span class="line"> <span class="built_in">super</span>(name);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 重写run⽅法</span></span><br><span class="line"><span class="comment"> * 定义线程要执⾏的代码</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line"> <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line"> <span class="comment">//getName()⽅法 来⾃⽗亲</span></span><br><span class="line"> System.out.println(getName() + i);</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span> &#123;</span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"> System.out.println(<span class="string">&quot;这⾥是main线程&quot;</span>);</span><br><span class="line"> <span class="type">MyThread</span> <span class="variable">mt</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread</span>(<span class="string">&quot;⼩强&quot;</span>);</span><br><span class="line"> mt.start(); <span class="comment">// 开启了⼀个新的线程</span></span><br><span class="line"> <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line"> System.out.println(<span class="string">&quot;旺财:&quot;</span> + i);</span><br><span class="line"> &#125;</span><br><span class="line"> &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>流程图：</p><p><img src="https://gitee.com/Button_mkns/picgo/raw/master/img/image-20231016113724391.png" alt="image-20231016113724391"></p><p>程序启动运⾏ main 时候， java 虚拟机启动⼀个进程，主线程 main 在 main() 调⽤时候被创建。随着调⽤mt 的对象的 start ⽅法，另外⼀个新的线程也启动了，这样，整个应⽤就在多线程下运⾏。<br>通过这张图我们可以很清晰的看到多线程的执⾏流程，那么为什么可以完成并发执⾏呢？我们再来讲⼀讲原理。<br>多线程执⾏时，到底在内存中是如何运⾏的呢？以上个程序为例，进⾏图解说明：<br>多线程执⾏时，在栈内存中，其实 <strong>每⼀个执⾏线程都有⼀⽚⾃⼰所属的栈内存空间</strong>。 进⾏⽅法的压栈和弹栈。</p><p><img src="https://gitee.com/Button_mkns/picgo/raw/master/img/image-20231016114035936.png" alt="image-20231016114035936"></p><p>​     当执⾏线程的任务结束了，线程⾃动在栈内存中释放了。但是当     <strong>所有的执⾏线程</strong>     都结束了（“前置”线程结束了），进程才结束了。    </p><h3 id="2-2-Thread类"><a href="#2-2-Thread类" class="headerlink" title="2.2 Thread类"></a>2.2 Thread<strong>类</strong></h3><p><strong>构造⽅法：</strong></p><ul><li>public Thread() ：分配⼀个新的线程对象。</li><li>public Thread(String name) ：分配⼀个指定名字的新的线程对象。</li><li>public Thread(Runnable target) ：分配⼀个带有指定⽬标新的线程对象。</li><li>public Thread(Runnable target, String name) ：分配⼀个带有指定⽬标新的线程对象并指定名字。</li></ul><p><strong>常⽤⽅法：</strong></p><ul><li>public String getName() ：获取当前线程名称。</li><li>public void start() ：导致此线程开始执⾏；Java虚拟机调⽤此线程的run⽅法。</li><li>public void run() ：此线程要执⾏的任务在此处定义代码。</li><li>public static void sleep(long millis) ：使当前正在执⾏的线程以指定的毫秒数暂停（暂时停⽌执⾏）。</li><li>public static Thread currentThread() ：返回对当前正在执⾏的线程对象的引⽤。</li></ul><h3 id="2-3-创建线程⽅式⼆"><a href="#2-3-创建线程⽅式⼆" class="headerlink" title="2.3 创建线程⽅式⼆"></a>2.3 <strong>创建线程⽅式⼆</strong></h3><p>采⽤ <strong>java.lang.Runnable</strong> 也是⾮常常⻅的⼀种，我们只需要重写 <strong>run</strong>⽅法即可。      </p><p>步骤如下：</p><ol><li>定义 Runnable 接⼝的实现类，并重写该接⼝的 run() ⽅法，该 run() ⽅法的⽅法体同样是该线程的线程执⾏体。</li><li>创建 Runnable 实现类的实例，并以此实例作为 Thread 的 target 来创建 Thread 对象，该 Thread 对象才是 真正的线程对象。</li><li>调⽤线程对象的 start() ⽅法来启动线程。</li></ol><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyRunnable</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line"> <span class="meta">@Override</span></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line"> <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line"> System.out.println(Thread.currentThread().getName() + <span class="string">&quot; &quot;</span> + i);</span><br><span class="line"> &#125;</span><br><span class="line"> &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span> &#123;</span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"> <span class="comment">// 创建⾃定义类对象 线程任务对象</span></span><br><span class="line"> <span class="type">MyRunnable</span> <span class="variable">mr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyRunnable</span>();</span><br><span class="line"> <span class="comment">// 创建线程对象</span></span><br><span class="line"> <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(mr, <span class="string">&quot;⼩强&quot;</span>);</span><br><span class="line"> t.start();</span><br><span class="line"> <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line"> System.out.println(<span class="string">&quot;旺财 &quot;</span> + i);</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过实现 Runnable 接⼝，使得该类有了多线程类的特征。 run() ⽅法是多线程程序的⼀个执⾏⽬标。所有的多线程代码都在 run ⽅法⾥⾯。 Thread 类实际上也是实现了 Runnable 接⼝的类。<br>在启动的多线程的时候，需要先通过 Thread 类的构造⽅法 Thread(Runnable target) 构造出对象，然后调⽤Thread 对象的 start() ⽅法来运⾏多线程代码。<br>实际上所有的多线程代码都是通过运⾏ Thread 的 start() ⽅法来运⾏的。因此，不管是继承 Thread 类还是实现 Runnable 接⼝来实现多线程，最终还是通过 Thread 的对象的 API 来控制线程的，熟悉 Thread 类的 API 是进⾏多线程编程的基础。</p><h3 id="2-4-Thread-和-Runnable-的区别"><a href="#2-4-Thread-和-Runnable-的区别" class="headerlink" title="2.4 Thread 和 Runnable 的区别"></a><strong>2.4 Thread 和 Runnable 的区别</strong></h3><p>如果⼀个类继承   Thread  ，则不适合资源共享。但是如果实现了   Runable   接⼝的话，则很容易的实现资源共享。  </p><p><strong>总结：</strong></p><p><strong>实现</strong>   Runnable   <strong>接⼝⽐继承</strong>   Thread   <strong>类所具有的优势：</strong></p><ol><li>适合多个相同的程序代码的线程去共享同⼀个资源。</li><li>可以避免 java 中的单继承的局限性。</li><li>增加程序的健壮性，实现解耦操作，代码可以被多个线程共享，代码和线程独⽴。</li><li>线程池只能放⼊实现 Runable 或 Callable 类线程，不能直接放⼊继承 Thread 的类。</li></ol><h3 id="2-5-匿名内部类⽅式实现线程的创建"><a href="#2-5-匿名内部类⽅式实现线程的创建" class="headerlink" title="2.5 匿名内部类⽅式实现线程的创建"></a>2.5 <strong>匿名内部类⽅式实现线程的创建</strong></h3><p>  使⽤线程的匿名内部类⽅式，可以⽅便的实现每个线程执⾏不同的线程任务操作。  </p><p>  使⽤匿名内部类的⽅式实现   Runnable   接⼝，重写   Runnable   接⼝中的   run   ⽅法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NoNameInnerClassThread</span> &#123;</span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="comment">// new Runnable() &#123;</span></span><br><span class="line"><span class="comment">// public void run() &#123;</span></span><br><span class="line"><span class="comment">// for (int i = 0; i &lt; 20; i++) &#123;</span></span><br><span class="line"><span class="comment">// System.out.println(&quot;张宇:&quot; + i);</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"><span class="comment">// &#125;; //---这个整体 相当于new MyRunnable()</span></span><br><span class="line"> <span class="type">Runnable</span> <span class="variable">r</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line"> <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line"> System.out.println(<span class="string">&quot;张宇:&quot;</span> + i);</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;;</span><br><span class="line"> </span><br><span class="line"> <span class="keyword">new</span> <span class="title class_">Thread</span>(r).start();</span><br><span class="line"> <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line"> System.out.println(<span class="string">&quot;费⽟清:&quot;</span> + i);</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-线程安全"><a href="#3-线程安全" class="headerlink" title="3 线程安全"></a>3 <strong>线程安全</strong></h2><h3 id="3-1-线程安全"><a href="#3-1-线程安全" class="headerlink" title="3.1 线程安全"></a>3.1 <strong>线程安全</strong></h3><p>如果有多个线程在同时运⾏，⽽这些线程可能会同时运⾏这段代码。程序每次运⾏结果和单线程运⾏的结果是⼀样的，⽽且其他的变量的值也和预期的是⼀样的，就是线程安全的。<br>我们通过⼀个案例，演示线程的安全问题：<br>电影院要卖票，我们模拟电影院的卖票过程。假设要播放的电影是 “ 葫芦娃⼤战奥特曼 ” ，本次电影的座位 共 100 个（本场电影只能卖 100 张票）。<br>我们来模拟电影院的售票窗⼝，实现多个窗⼝同时卖 “ 葫芦娃⼤战奥特曼 ” 这场电影票（多个窗⼝⼀起卖这100 张票）<br>需要窗⼝，采⽤线程对象来模拟；需要票， Runnable 接⼝⼦类来模拟<br>模拟票：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Ticket</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line"> <span class="keyword">private</span> <span class="type">int</span> <span class="variable">ticket</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line"> <span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 执⾏卖票操作</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> <span class="meta">@Override</span></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line"> <span class="comment">// 每个窗⼝卖票的操作</span></span><br><span class="line"> <span class="comment">// 窗⼝ 永远开启</span></span><br><span class="line"> <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line"> <span class="keyword">if</span> (ticket &gt; <span class="number">0</span>) &#123;<span class="comment">// 有票 可以卖</span></span><br><span class="line"> <span class="comment">// 出票操作</span></span><br><span class="line"> <span class="comment">// 使⽤sleep模拟⼀下出票时间</span></span><br><span class="line"> <span class="keyword">try</span> &#123;</span><br><span class="line"> Thread.sleep(<span class="number">100</span>);</span><br><span class="line"> &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line"> e.printStackTrace();</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">// 获取当前线程对象的名字</span></span><br><span class="line"> <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> Thread.currentThread().getName();</span><br><span class="line"> System.out.println(name + <span class="string">&quot;正在卖:&quot;</span> + ticket--);</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span> &#123;</span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"> <span class="comment">// 创建线程任务对象</span></span><br><span class="line"> <span class="type">Ticket</span> <span class="variable">ticket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Ticket</span>();</span><br><span class="line"> <span class="comment">// 创建三个窗⼝对象</span></span><br><span class="line"> <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(ticket, <span class="string">&quot;窗⼝1&quot;</span>);</span><br><span class="line"> <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(ticket, <span class="string">&quot;窗⼝2&quot;</span>);</span><br><span class="line"> <span class="type">Thread</span> <span class="variable">t3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(ticket, <span class="string">&quot;窗⼝3&quot;</span>);</span><br><span class="line"> </span><br><span class="line"> <span class="comment">// 同时卖票</span></span><br><span class="line"> t1.start();</span><br><span class="line"> t2.start();</span><br><span class="line"> t3.start();</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果中有⼀部分这样现象</p><p><img src="https://gitee.com/Button_mkns/picgo/raw/master/img/image-20231016142525662.png" alt="image-20231016142525662"></p><p>发现程序出现了两个问题：</p><ol><li>相同的票数，⽐如 2 这张票被卖了两回。</li><li>不存在的票，⽐如 0 票与 -1 票，是不存在的。<br>这种问题，⼏个窗⼝（线程）票数不同步了，这种问题称为线程安全性问题。</li></ol><h3 id="3-2-线程同步"><a href="#3-2-线程同步" class="headerlink" title="3.2 线程同步"></a>3.2 <strong>线程同步</strong></h3><p>当我们使⽤多个线程访问同⼀资源的时候，且多个线程中对资源有写的操作，就容易出现线程安全问题。<br>要解决上述多线程并发访问⼀个资源的安全性问题：也就是解决重复票与不存在票问题， Java 中提供了同 步机制 （ synchronized ） 来解决。<br>根据案例简述：</p><blockquote><p>窗⼝1线程进⼊操作的时候，窗⼝2和窗⼝3线程只能在外等着，窗⼝1操作结束，窗⼝1和窗⼝2和窗⼝3才有机会进⼊代码去执⾏。也就是说在某个线程修改共享资源的时候，其他线程不能修改该资源，等待修改完毕同步之后，才能去抢夺CPU资源，完成对应的操作，保证了数据的同步性，解决了线程不安全的现象。</p></blockquote><p>为了保证每个线程都能正常执⾏原⼦操作， Java 引⼊了线程同步机制。<br>那么怎么去使⽤呢？有三种⽅式完成同步操作：</p><ol><li>同步代码块。</li><li>同步⽅法。</li><li>锁机制。</li></ol><h3 id="3-3-同步代码块"><a href="#3-3-同步代码块" class="headerlink" title="3.3 同步代码块"></a>3.3 <strong>同步代码块</strong></h3><ul><li><strong>同步代码块：</strong> synchronized 关键字可以⽤于⽅法中的某个区块中，表示只对这个区块的资源实⾏互斥访问。</li></ul><p>格式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span>(同步锁) &#123;</span><br><span class="line"> 需要同步操作的代码</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>同步锁：</strong></p><blockquote><p>对象的同步锁只是⼀个概念，可以想象为在对象上标记了⼀个锁。      </p><p>​      1.  锁对象，可以是任意类型。      </p><p>​      2.  多个线程对象，要使⽤同⼀把锁。      </p></blockquote><p>使用同步代码块解决问题：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Ticket</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line"> <span class="keyword">private</span> <span class="type">int</span> <span class="variable">ticket</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line"> <span class="type">Object</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"> <span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 执⾏卖票操作</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> <span class="meta">@Override</span></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line"> <span class="comment">// 每个窗⼝卖票的操作</span></span><br><span class="line"> <span class="comment">// 窗⼝ 永远开启</span></span><br><span class="line"> <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line"> <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line"> <span class="keyword">if</span> (ticket &gt; <span class="number">0</span>) &#123; <span class="comment">// 有票 可以卖</span></span><br><span class="line"> <span class="comment">// 出票操作</span></span><br><span class="line"> <span class="comment">// 使⽤sleep模拟⼀下出票时间</span></span><br><span class="line"> <span class="keyword">try</span> &#123;</span><br><span class="line"> Thread.sleep(<span class="number">50</span>);</span><br><span class="line"> &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line"> e.printStackTrace();</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">// 获取当前线程对象的名字</span></span><br><span class="line"> <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> Thread.currentThread().getName();</span><br><span class="line"> System.out.println(name + <span class="string">&quot;正在卖: &quot;</span> + ticket--);</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-4-同步⽅法"><a href="#3-4-同步⽅法" class="headerlink" title="3.4 同步⽅法"></a>3.4 <strong>同步⽅法</strong></h3><ul><li><strong>同步⽅法：</strong>使⽤ synchronized 修饰的⽅法，就叫做同步⽅法，保证A线程执⾏该⽅法的时候，其他线程只能在⽅法外等着</li></ul><p>格式：</p><blockquote><p>public synchronized void method() {<br> 可能会产⽣线程安全问题的代码<br>}</p></blockquote><p>使用同步方法代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Ticket</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line"> <span class="keyword">private</span> <span class="type">int</span> <span class="variable">ticket</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line"> <span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 执⾏卖票操作</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> <span class="meta">@Override</span></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line"> <span class="comment">// 每个窗⼝卖票的操作</span></span><br><span class="line"> <span class="comment">// 窗⼝ 永远开启</span></span><br><span class="line"> <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line"> sellTicket();</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 锁对象 是 谁调⽤这个⽅法 就是谁</span></span><br><span class="line"><span class="comment"> * 隐含 锁对象 就是 this</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">sellTicket</span><span class="params">()</span> &#123;</span><br><span class="line"> <span class="keyword">if</span> (ticket &gt; <span class="number">0</span>) &#123; <span class="comment">// 有票 可以卖</span></span><br><span class="line"> <span class="comment">// 出票操作</span></span><br><span class="line"> <span class="comment">// 使⽤sleep模拟⼀下出票时间</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"> Thread.sleep(<span class="number">100</span>);</span><br><span class="line"> &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line"> e.printStackTrace();</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">// 获取当前线程对象的名字</span></span><br><span class="line"> <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> Thread.currentThread().getName();</span><br><span class="line"> System.out.println(name + <span class="string">&quot;正在卖:&quot;</span> + ticket--);</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-5-Lock锁"><a href="#3-5-Lock锁" class="headerlink" title="3.5 Lock锁"></a>3.5 Lock<strong>锁</strong></h3><p>java.util.concurrent.locks.Lock 机制提供了⽐ synchronized 代码块和 synchronized ⽅法更⼴泛的<br>锁定操作，同步代码块 &#x2F; 同步⽅法具有的功能 Lock 都有，除此之外更强⼤，更体现⾯向对象。<br>Lock 锁也称同步锁，创建对象 Lock lock &#x3D; new ReentrantLock() ，加锁与释放锁⽅法如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">public void lock() ：加同步锁。</span><br><span class="line">public void unlock() ：释放同步锁。</span><br></pre></td></tr></table></figure><p>使⽤如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Ticket</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line"> <span class="keyword">private</span> <span class="type">int</span> <span class="variable">ticket</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line"> </span><br><span class="line"> <span class="type">Lock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line"> <span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 执⾏卖票操作</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> <span class="meta">@Override</span></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line"> <span class="comment">// 每个窗⼝卖票的操作</span></span><br><span class="line"> <span class="comment">// 窗⼝ 永远开启</span></span><br><span class="line"> <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line"> lock.lock();</span><br><span class="line"> <span class="keyword">if</span> (ticket &gt; <span class="number">0</span>) &#123; <span class="comment">// 有票 可以卖</span></span><br><span class="line"> <span class="comment">// 出票操作</span></span><br><span class="line"> <span class="comment">// 使⽤sleep模拟⼀下出票时间</span></span><br><span class="line"> <span class="keyword">try</span> &#123;</span><br><span class="line"> Thread.sleep(<span class="number">50</span>);</span><br><span class="line"> &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line"> e.printStackTrace();</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">// 获取当前线程对象的名字</span></span><br><span class="line"> <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> Thread.currentThread().getName();</span><br><span class="line">System.out.println(name + <span class="string">&quot;正在卖:&quot;</span> + ticket--);</span><br><span class="line"> &#125;</span><br><span class="line"> lock.unlock();</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-线程状态"><a href="#4-线程状态" class="headerlink" title="4 线程状态"></a>4 <strong>线程状态</strong></h2><h3 id="4-1-线程状态概述"><a href="#4-1-线程状态概述" class="headerlink" title="4.1 线程状态概述"></a>4.1 <strong>线程状态概述</strong></h3><p>当线程被创建并启动以后，它既不是⼀启动就进⼊了执⾏状态，也不是⼀直处于执⾏状态。在线程的⽣命 周期中，有⼏种状态呢？在 API 中 java.lang.Thread.State 这个枚举中给出了六种线程状态：<br>这⾥先列出各个线程状态发⽣的条件，下⾯将会对每种状态进⾏详细解析</p><p><img src="https://gitee.com/Button_mkns/picgo/raw/master/img/image-20231016143638511.png" alt="image-20231016143638511"></p><h3 id="4-2-Timed-Waiting（计时等待）"><a href="#4-2-Timed-Waiting（计时等待）" class="headerlink" title="4.2 Timed Waiting（计时等待）"></a>4.2 Timed Waiting<strong>（计时等待</strong>）</h3><p><img src="https://gitee.com/Button_mkns/picgo/raw/master/img/image-20231016144209916.png" alt="image-20231016144209916"></p><h3 id="4-3-BLOCKED（锁阻塞）"><a href="#4-3-BLOCKED（锁阻塞）" class="headerlink" title="4.3 BLOCKED（锁阻塞）"></a>4.3 BLOCKED<strong>（锁阻塞）</strong></h3><p>Blocked 状态在 API 中的介绍为：⼀个正在阻塞等待⼀个监视器锁（锁对象）的线程处于这⼀状态。<br>我们已经学完同步机制，那么这个状态是⾮常好理解的了。⽐如，线程 A 与线程 B 代码中使⽤同⼀锁，如果 线程 A 获取到锁，线程 A 进⼊到 Runnable 状态，那么线程 B 就进⼊到 Blocked 锁阻塞状态。<br>这是由 Runnable 状态进⼊ Blocked 状态。除此 Waiting 以及 Time Waiting 状态也会在某种情况下进⼊阻塞状态，⽽这部分内容作为扩充知识点带领⼤家了解⼀下。<br>Blocked 线程状态图：<br><img src="https://gitee.com/Button_mkns/picgo/raw/master/img/image-20231016144306908.png" alt="image-20231016144306908"></p><h3 id="4-4-Waiting（⽆限等待）"><a href="#4-4-Waiting（⽆限等待）" class="headerlink" title="4.4 Waiting（⽆限等待）"></a>4.4 Waiting<strong>（⽆限等待）</strong></h3><p><img src="https://gitee.com/Button_mkns/picgo/raw/master/img/image-20231016144357148.png" alt="image-20231016144357148"></p><h2 id="5-小结"><a href="#5-小结" class="headerlink" title="5 小结"></a>5 小结</h2><p><img src="https://gitee.com/Button_mkns/picgo/raw/master/img/image-20231016144438935.png" alt="image-20231016144438935"></p><p><img src="https://gitee.com/Button_mkns/picgo/raw/master/img/image-20231016144456295.png" alt="image-20231016144456295"></p><p><img src="https://gitee.com/Button_mkns/picgo/raw/master/img/image-20231016144504900.png" alt="image-20231016144504900"></p><blockquote><p><strong>多线程</strong>: 父类 Thread<br>  <strong>程序</strong>: 软件, 工程<br>  <strong>进程</strong>: 正在运行的程序<br>  <strong>线程</strong>: 进程中的任务单位</p><p>  CPU 可以”同时”处理多个线程<br>  <strong>并行</strong>: 同一时刻, 同时运行, 通常需要多核处理器<br>  <strong>并发</strong>: 多线程, 交替执行(交替速度足够快, 看起来是同时)<br><strong>实现多线程:</strong></p><p>  main -&gt; 一个线程<br>  执行多线程: 随机性</p><p>  <strong>方式一: 只能继承一个类, 功能性单一</strong><br>    1.自定义类, 继承Thread<br>    2.重写run方法<br>    3.在主程序中创建线程对象<br>    4.开启线程 start()</p><p>  <strong>方式二: 实现接口</strong><br>    1.自定义类, 实现Runnable接口<br>    2.实现run方法<br>    3.创建线程对象  ※  使用Runnable对象来构造<br>    4.开启线程 start</p><p>  <strong>方式三: 匿名内部类</strong></p><p>Thread 基础的API:<br>  String getName(): Thread 属性 name<br>  static Thread currentThread(): 获得当前线程对象<br>  static void sleep(long time): 当前线程的阻塞时间</p><p><strong>线程的状态</strong>:<br>    见图</p><p><strong>线程安全:</strong> 多个线程共享资源<br><strong>解决安全:</strong> 实现线程同步<br>         <strong>加锁:</strong> 同步锁  synchronized, 需要借助一个对象<br>              Lock锁  接口  实现类 ReentrantLock()<br>                 上锁 lock()  解锁 unlock()</p><p><strong>线程其他属性和方法:</strong><br>    setPriority(1-10越来越大): 设置优先级, 提升了这个线程的执行概率<br>    setDaemon(true): 设置守护线程, 所有的”前置”线程结束, 守护线程也将自动结束<br>                     GC -&gt; 垃圾回收(守护线程)<br>                     System.gc() -&gt; 手动清理</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 亚信实习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JAVA基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>反射</title>
      <link href="/2023/10/13/%E4%BA%9A%E4%BF%A1%E5%AE%9E%E4%B9%A0/%E7%AC%AC%E4%B8%80%E6%9C%88/day10-11/%E5%8F%8D%E5%B0%84/"/>
      <url>/2023/10/13/%E4%BA%9A%E4%BF%A1%E5%AE%9E%E4%B9%A0/%E7%AC%AC%E4%B8%80%E6%9C%88/day10-11/%E5%8F%8D%E5%B0%84/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/>## 反射的概述<p>JAVA反射机制是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意一个方法和属性；这种动态获取的信息以及动态调用对象的方法的功能称为java语言的反射机制。<br>要想解剖一个类,必须先要获取到该类的字节码文件对象。而解剖使用的就是Class类中的方法.所以先要获取到每一个字节码文件对应的Class类型的对象.<br><strong>以上的总结就是什么是反射</strong><br>反射就是把java类中的各种成分映射成一个个的<strong>Java对象</strong><br>例如：一个类有：<strong>成员变量</strong>、<strong>方法</strong>、<strong>构造方法</strong>、<strong>包</strong>等等信息，利用反射技术可以对一个类进行解剖，把个个组成部分映射成一个个对象。<br>     （其实：一个类中这些成员方法、构造方法、在加入类中都有一个类来描述）<br>如图是类的正常加载过程：反射的原理在与class对象。<br>熟悉一下加载的时候：Class对象的由来是将class文件读入内存，并为之创建一个Class对象。<br><img src="https://gitee.com/Button_mkns/picgo/raw/master/img/image-20231013154227893.png" alt="image-20231013154227893"></p><p><strong>利用反射＋多态优化很长的switch case</strong></p><p>原先的代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ParseJson</span> &#123;</span><br><span class="line">    <span class="comment">/* 待解析的json对象 */</span></span><br><span class="line">    JSONObject js;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 构造函数，获取json */</span></span><br><span class="line">    ParseJson(JSONObject json) &#123;</span><br><span class="line">        <span class="built_in">this</span>.js  = json;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 解析json并获取相应的结果 */</span></span><br><span class="line">    String <span class="title function_">Parse</span><span class="params">()</span> <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line">        <span class="comment">/* 结果 */</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">iret</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">mark</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">/* 获得mark，创建对应的Executesql对象 */</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            mark = js.getInt(<span class="string">&quot;mark&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            result = <span class="string">&quot;&#123;\&quot;error\&quot;:0, \&quot;status\&quot;:\&quot;success\&quot;, \&quot;date\&quot;:\&quot;2015-08\&quot;, &quot;</span> +</span><br><span class="line">                    <span class="string">&quot;\&quot;result\&quot;:&#123;\&quot;requestPhoneNum\&quot;:\&quot;\&quot;, \&quot;IsSuccess\&quot;:\&quot;failure\&quot;,&quot;</span> +</span><br><span class="line">                    <span class="string">&quot;\&quot;mark\&quot;:0, \&quot;ResultINFO\&quot;:\&quot;json解析失败，您的输入有误\&quot;&#125;&#125;&quot;</span>;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">switch</span> (mark)&#123;</span><br><span class="line">            <span class="comment">/* mark == 1 检测此帐号是否正确且被注册过 */</span></span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* mark == 2  帐号注册*/</span></span><br><span class="line">            <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="comment">/* mark == 3 忘记密码 注意：应该验证密宝后返回用户一个key值，mark4根据key值来改新密码 */</span></span><br><span class="line">            <span class="keyword">case</span>  <span class="number">3</span>:</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* mark ==4 用户更新密码 */</span></span><br><span class="line">            <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* mark ==5 用户更新信息</span></span><br><span class="line"><span class="comment">             * 自己的name，头像等</span></span><br><span class="line"><span class="comment">             * 一般用户点击详细信息会有更新操作 */</span></span><br><span class="line">            <span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="comment">/* mark ==6</span></span><br><span class="line"><span class="comment">             * 登记新的联系方式</span></span><br><span class="line"><span class="comment">             * 需要修改UserFriend 好友and me 的 is update</span></span><br><span class="line"><span class="comment">             * 每次好友登录需要检查好友的isupdate</span></span><br><span class="line"><span class="comment">             * 看谁换联系方式了 */</span></span><br><span class="line">            <span class="keyword">case</span> <span class="number">6</span>:</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* mark == 7</span></span><br><span class="line"><span class="comment">            *  说明本地没有数据，客户端需要发送全部数据 */</span></span><br><span class="line">            <span class="keyword">case</span> <span class="number">7</span>:</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* mark == 8</span></span><br><span class="line"><span class="comment">            *  说明本地有数据，只更新发送好友的数据</span></span><br><span class="line"><span class="comment">            *  相当于下拉刷新 */</span></span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">            *  先通过account 获得用户 uid</span></span><br><span class="line"><span class="comment">            *  uid 获取 friendId</span></span><br><span class="line"><span class="comment">            *  friendId and uid 获取不为0的 isUpdate数据</span></span><br><span class="line"><span class="comment">            *  分析isUpdate数据，找出标记，组装好友更新的数据，返回</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">            <span class="keyword">case</span> <span class="number">8</span>:</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* mark == 9</span></span><br><span class="line"><span class="comment">            *  添加联系人，UserFriend中添加数据，注意要返回好友的信息 */</span></span><br><span class="line">            <span class="keyword">case</span> <span class="number">9</span>:</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* mark == 10</span></span><br><span class="line"><span class="comment">            *  生成二维码加好友 */</span></span><br><span class="line">            <span class="keyword">case</span> <span class="number">10</span>:</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* mark == 11</span></span><br><span class="line"><span class="comment">            *  生成二维码</span></span><br><span class="line"><span class="comment">            *  客户端生成一张二维码发送给服务器服务器保存 */</span></span><br><span class="line">            <span class="keyword">case</span> <span class="number">11</span>:</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* mark ==12</span></span><br><span class="line"><span class="comment">             * 登录*/</span></span><br><span class="line">            <span class="keyword">case</span> <span class="number">12</span>:</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="comment">/* mark == 13</span></span><br><span class="line"><span class="comment">            *  删除联系人 */</span></span><br><span class="line">            <span class="keyword">case</span> <span class="number">13</span>:</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="comment">/* mark == 14</span></span><br><span class="line"><span class="comment">            * 用户发送所有的个人信息,保存到数据库</span></span><br><span class="line"><span class="comment">            * */</span></span><br><span class="line">            <span class="keyword">case</span> <span class="number">14</span>:</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="使用多态加反射"><a href="#使用多态加反射" class="headerlink" title="使用多态加反射"></a><strong>使用多态加反射</strong></h4><p>1.首先，我提取出一个公共的基类，因为所有的请求都有类似的地方，比如每个请求都要响应函数。 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">request</span>&#123;</span><br><span class="line">    <span class="comment">/* 构造函数 */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">request</span><span class="params">(<span class="type">int</span> _mark, String _account)</span>&#123;</span><br><span class="line">        mark = _mark;</span><br><span class="line">        account = _account;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 响应函数 */</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">response</span><span class="params">()</span>&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">/* 共有字段 */</span></span><br><span class="line">    <span class="type">int</span> mark;</span><br><span class="line">    String account;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>拆分了这个大大的<strong>switch</strong>，把它每个case语句换成了一个对象，对象继承基类request</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">AccountRegister</span> <span class="keyword">extends</span> <span class="title class_">request</span>&#123;</span><br><span class="line">    <span class="comment">/* 构造函数 */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">AccountRegister</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">    <span class="comment">/* 覆盖response()函数 */</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">reponse</span><span class="params">()</span>&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">/* 属于自己的字段 */</span></span><br><span class="line">    String secret;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">AddFriendByAccount</span> <span class="keyword">extends</span> <span class="title class_">request</span>&#123;</span><br><span class="line">    <span class="comment">/* 构造函数 */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">AddFriendByAccount</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">    <span class="comment">/* 属于自己的response()函数 */</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">reponse</span><span class="params">()</span>&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">/* 属于自己的字段 */</span></span><br><span class="line">    String FriendId;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 亚信实习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JAVA基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>1. Spring Boot常用注解</title>
      <link href="/2023/10/11/%E4%BA%9A%E4%BF%A1%E5%AE%9E%E4%B9%A0/%E7%AC%AC%E4%B8%80%E6%9C%88/day10-11/%E5%B8%B8%E7%94%A8%E6%B3%A8%E8%A7%A3/"/>
      <url>/2023/10/11/%E4%BA%9A%E4%BF%A1%E5%AE%9E%E4%B9%A0/%E7%AC%AC%E4%B8%80%E6%9C%88/day10-11/%E5%B8%B8%E7%94%A8%E6%B3%A8%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/><ol><li><code>@SpringBootApplication</code>：这是一个方便的注解，它包括了以下三个注解：<code>@Configuration</code>，<code>@EnableAutoConfiguration</code> 和 <code>@ComponentScan</code>。它表示一个 Spring Boot 应用程序的起点。</li><li><code>@RestController</code>：这个注解用于标记一个类作为控制器，并且其中的所有方法都会被视为 RESTful API。这个注解等价于 <code>@Controller</code> 和 <code>@ResponseBody</code> 的组合。</li><li><code>@RequestMapping</code>：这个注解用于将一个方法映射到一个 URL。它可以用在类或方法上，默认值是 “&#x2F;“。</li><li><code>@GetMapping</code>、<code>@PostMapping</code>、<code>@PutMapping</code>、<code>@DeleteMapping</code>：这些注解是 <code>@RequestMapping</code> 的快捷方式，用于映射 HTTP GET、POST、PUT、DELETE 请求到特定的处理方法。</li><li><code>@PathVariable</code>：这个注解用于绑定 URL 中的路径变量到方法的参数上。</li><li><code>@RequestParam</code>：这个注解用于绑定 URL 的查询参数或请求体中的数据到方法的参数上。</li><li><code>@RequestBody</code>：这个注解用于绑定 HTTP 请求体中的数据到方法的参数上。通常与 POST 和 PUT 请求一起使用。</li><li><code>@ResponseBody</code>：这个注解用于将方法的返回值直接写入 HTTP 响应体中。通常与 RESTful API 一起使用。</li><li><code>@Component</code>：这个注解用于标记一个类作为 Spring Bean，并且会被自动扫描和装配。</li><li><code>@Service</code>：这个注解用于标记一个服务类，并且会被自动注入到需要它的组件中。</li><li><code>@Repository</code>：这个注解用于标记一个数据访问对象（DAO）类，并且会被自动注入到需要它的组件中。</li><li><code>@ControllerAdvice</code>：这个注解用于将全局异常处理统一到一个类中。</li><li><code>@ExceptionHandler</code>：这个注解用于为特定的异常类型定义一个处理方法。</li><li><code>@Autowired</code>：这个注解用于自动装配 Spring Bean，可以作用于类、属性、方法和构造函数上。</li><li><code>@Qualifier</code>：这个注解用于指定一个 Spring Bean 的名称，当存在同类型的多个 Bean 时使用。</li><li><code>@Value</code>：这个注解用于注入配置文件中的值，支持占位符和 SpEL 表达式。</li><li><code>@ConfigurationProperties</code>：这个注解用于将配置文件中的属性绑定到一个类中，可以将配置文件中的多个属性映射为一个类的多个属性或方法。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 亚信实习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> springboot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>sql常用</title>
      <link href="/2023/10/10/%E4%BA%9A%E4%BF%A1%E5%AE%9E%E4%B9%A0/%E7%AC%AC%E4%B8%80%E6%9C%88/day08/sql%E6%9D%82%E8%AE%B0/"/>
      <url>/2023/10/10/%E4%BA%9A%E4%BF%A1%E5%AE%9E%E4%B9%A0/%E7%AC%AC%E4%B8%80%E6%9C%88/day08/sql%E6%9D%82%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/>**升序降序**<p>ORDER BY DESC 降序 ORDER BY ASC 升序</p><p><strong>分页</strong>  LIMIT</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> table_name LIMIT <span class="number">20</span>, <span class="number">10</span>;</span><br></pre></td></tr></table></figure><p><strong>distinct</strong> 搜索去重</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">prod_price <span class="keyword">BETWEEN</span> <span class="number">3</span> <span class="keyword">AND</span> <span class="number">6</span></span><br></pre></td></tr></table></figure><p>模糊查找 <strong>LIKE</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> prod_name , prod_desc <span class="keyword">from</span> Products <span class="keyword">where</span> prod_desc <span class="keyword">like</span> <span class="string">&#x27;%toy%&#x27;</span></span><br></pre></td></tr></table></figure><p><strong>locate</strong>函数：检查是否包含某字符串。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 1.locate函数：Locate(str,sub) &gt; 0，表示sub字符串包含str字符串；Locate(str,sub) = 0，表示sub字符串不包含str字符串。</span><br><span class="line">select prod_name,prod_desc from Products</span><br><span class="line">where locate(&quot;toy&quot;,prod_desc) = 0</span><br><span class="line">order by prod_name asc</span><br></pre></td></tr></table></figure><p><strong>instr(filed,str)函数</strong>：返回str子字符串在filed字符串的第一次出现位置</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> prod_name,prod_desc <span class="keyword">from</span> Products</span><br><span class="line"><span class="keyword">where</span> instr(prod_desc,&quot;toy&quot;) <span class="operator">=</span> <span class="number">0</span></span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> prod_name <span class="keyword">asc</span></span><br></pre></td></tr></table></figure><p><strong>not like</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> prod_name,prod_desc <span class="keyword">from</span> Products</span><br><span class="line"><span class="keyword">where</span> prod_desc <span class="keyword">not</span> <span class="keyword">like</span> &quot;%toy%&quot;</span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> prod_name <span class="keyword">asc</span></span><br></pre></td></tr></table></figure><p><strong>substing,concat,upper，lower</strong></p><ul><li>字符串的截取：substring(字符串，起始位置，截取字符数）</li><li>字符串的拼接：concat(字符串1，字符串2，字符串3,…)</li><li>字母大写：upper(字符串）</li><li>字母小写：lower</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> cust_id , cust_name , <span class="built_in">upper</span>(concat(<span class="built_in">substring</span>(cust_contact,<span class="number">1</span>,<span class="number">2</span>),<span class="built_in">substring</span>(cust_city,<span class="number">1</span>,<span class="number">3</span>))) <span class="keyword">as</span> user_login <span class="keyword">from</span> Customers</span><br></pre></td></tr></table></figure><p><strong>截取时间</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">from</span> Orders</span><br><span class="line"><span class="keyword">where</span> <span class="keyword">month</span>(order_date) <span class="operator">=</span> <span class="number">1</span> <span class="keyword">and</span> <span class="keyword">year</span>(order_date) <span class="operator">=</span> <span class="number">2020</span></span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> order_date</span><br></pre></td></tr></table></figure><p><strong>取最大数</strong></p><p>MAX()</p><p>分组计数：count( ) group by</p><p><strong>注：</strong>group by 和order by连用的时候要注意，order by要在后面</p><p><strong>having</strong></p><ul><li>where—过滤指定的行</li><li>having–过滤分组，与group by连用</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> order_num</span><br><span class="line"><span class="keyword">from</span> OrderItems</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> order_num</span><br><span class="line"><span class="keyword">having</span> <span class="built_in">sum</span>(quantity)<span class="operator">&gt;=</span><span class="number">100</span></span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> order_num</span><br></pre></td></tr></table></figure><p><strong>获取月份最后一天</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">choose</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">when</span> <span class="attr">test</span>=<span class="string">&quot;zzType != 1&quot;</span>&gt;</span>and DAY_ID = date_format(LAST_DAY(str_to_date(concat(#&#123;date&#125;,&#x27;01&#x27;),&#x27;%Y%m%d&#x27;)),&#x27;%Y%m%d&#x27;)<span class="tag">&lt;/<span class="name">when</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">otherwise</span>&gt;</span>and DAY_ID = #&#123;date&#125;<span class="tag">&lt;/<span class="name">otherwise</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">choose</span>&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 亚信实习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据并行化</title>
      <link href="/2023/10/07/%E4%BA%9A%E4%BF%A1%E5%AE%9E%E4%B9%A0/%E7%AC%AC%E4%B8%80%E6%9C%88/day05-%E7%B1%BB%E5%BA%93/%E6%95%B0%E6%8D%AE%E5%B9%B6%E8%A1%8C%E5%8C%96/"/>
      <url>/2023/10/07/%E4%BA%9A%E4%BF%A1%E5%AE%9E%E4%B9%A0/%E7%AC%AC%E4%B8%80%E6%9C%88/day05-%E7%B1%BB%E5%BA%93/%E6%95%B0%E6%8D%AE%E5%B9%B6%E8%A1%8C%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/># 数据并行化<h2 id="并行和并发"><a href="#并行和并发" class="headerlink" title="并行和并发"></a>并行和并发</h2><p><img src="https://gitee.com/Button_mkns/picgo/raw/master/img/image-20231007141942059.png" alt="image-20231007141942059"></p><p><strong>并发是两个任务共享时间段，并行则是两个任务在同一时间发生</strong></p><p><strong>并行化是指为缩短任务执行时间，将一个任务分解成几部分，然后并行执行。</strong>这和顺序执 行的任务量是一样的，区别就像用更多的马来拉车，花费的时间自然减少了。实际上，和 顺序执行相比，并行化执行任务时，CPU 承载的工作量更大。</p><h2 id="为什么并行化流操作"><a href="#为什么并行化流操作" class="headerlink" title="为什么并行化流操作"></a>为什么并行化流操作</h2><p><strong>并 行 化 操 作 流 只 需 改 变 一 个 方 法 调 用。</strong> 如 果 已 经 有 一 个 Stream 对 象， 调 用 它 的 <strong>parallel 方法</strong>就能让其拥有并行操作的能力。如果想从一个<strong>集合类</strong>创建一个流，调用 <strong>parallelStream</strong> 就能立即获得一个拥有并行能力的流。</p><blockquote><p>串行化计算专辑曲目长度</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">serialArraySum</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">return</span> albums.stream()</span><br><span class="line">.flatMap(Album::getTracks)</span><br><span class="line">.mapToInt(Track::getLength)</span><br><span class="line">.sum();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>并行化计算专辑曲目长度</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">parallelArraySum</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">return</span> albums.parallelStream()</span><br><span class="line">.flatMap(Album::getTracks)</span><br><span class="line">.mapToInt(Track::getLength)</span><br><span class="line">.sum();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>在一个四核电脑上，如果有 10 张专辑，串行化代码的速 度是并行化代码速度的 8 倍；如果将专辑数量增至 100 张，串行化和并行化速度相当；如 果将专辑数量增值 10 000 张，则并行化代码的速度是串行化代码速度的 2.5 倍。</p></blockquote><h3 id="通过手动使用线程模拟掷骰子事件"><a href="#通过手动使用线程模拟掷骰子事件" class="headerlink" title="通过手动使用线程模拟掷骰子事件"></a>通过手动使用线程模拟掷骰子事件</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ManualDiceRolls</span> &#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> fnal <span class="type">int</span> <span class="variable">N</span> <span class="operator">=</span> <span class="number">100000000</span>;</span><br><span class="line"><span class="keyword">private</span> fnal <span class="type">double</span> fraction;</span><br><span class="line"><span class="keyword">private</span> fnal Map&lt;Integer, Double&gt; results;</span><br><span class="line"><span class="keyword">private</span> fnal <span class="type">int</span> numberOfThreads;</span><br><span class="line"><span class="keyword">private</span> fnal ExecutorService executor;</span><br><span class="line"><span class="keyword">private</span> fnal <span class="type">int</span> workPerThread;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="type">ManualDiceRolls</span> <span class="variable">roles</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ManualDiceRolls</span>();</span><br><span class="line">roles.simulateDiceRoles();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ManualDiceRolls</span><span class="params">()</span> &#123;</span><br><span class="line">fraction = <span class="number">1.0</span> / N;</span><br><span class="line">results = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;&gt;();</span><br><span class="line">numberOfThreads = Runtime.getRuntime().availableProcessors();</span><br><span class="line">executor = Executors.newFixedThreadPool(numberOfThreads);</span><br><span class="line">workPerThread = N / numberOfThreads;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">simulateDiceRoles</span><span class="params">()</span> &#123;</span><br><span class="line">List&lt;Future&lt;?&gt;&gt; futures = submitJobs();</span><br><span class="line">awaitCompletion(futures);</span><br><span class="line">printResults();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">printResults</span><span class="params">()</span> &#123;</span><br><span class="line">results.entrySet()</span><br><span class="line">.forEach(System.out::println);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> List&lt;Future&lt;?&gt;&gt; submitJobs() &#123;</span><br><span class="line">List&lt;Future&lt;?&gt;&gt; futures = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; numberOfThreads; i++) &#123;</span><br><span class="line">futures.add(executor.submit(makeJob()));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> futures;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> Runnable <span class="title function_">makeJob</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">return</span> () -&gt; &#123;</span><br><span class="line"><span class="type">ThreadLocalRandom</span> <span class="variable">random</span> <span class="operator">=</span> ThreadLocalRandom.current();</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; workPerThread; i++) &#123;</span><br><span class="line"><span class="type">int</span> <span class="variable">entry</span> <span class="operator">=</span> twoDiceThrows(random);</span><br><span class="line">accumulateResult(entry);</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">accumulateResult</span><span class="params">(<span class="type">int</span> entry)</span> &#123;</span><br><span class="line">results.compute(entry, (key, previous) -&gt;</span><br><span class="line">previous == <span class="literal">null</span> ? fraction</span><br><span class="line">: previous + fraction</span><br><span class="line">);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="title function_">twoDiceThrows</span><span class="params">(ThreadLocalRandom random)</span> &#123;</span><br><span class="line"><span class="type">int</span> <span class="variable">firstThrow</span> <span class="operator">=</span> random.nextInt(<span class="number">1</span>, <span class="number">7</span>);</span><br><span class="line"><span class="type">int</span> <span class="variable">secondThrow</span> <span class="operator">=</span> random.nextInt(<span class="number">1</span>, <span class="number">7</span>);</span><br><span class="line"><span class="keyword">return</span> firstThrow + secondThrow;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">awaitCompletion</span><span class="params">(List&lt;Future&lt;?&gt;&gt; futures)</span> &#123;</span><br><span class="line">futures.forEach((future) -&gt; &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">future.get();</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException | ExecutionException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">executor.shutdown();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>数组上的并行化操作</p><p>parallelPrefix            任意给定一个函数，计算数组的和</p><p>parallelSetAll使用 Lambda 表达式更新数组元素</p><p>parallelSort并行化对数组元素排序</p><blockquote><p>使用 for 循环初始化数组</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">double</span>[] imperativeInitilize(<span class="type">int</span> size) &#123;</span><br><span class="line"><span class="type">double</span>[] values = <span class="keyword">new</span> <span class="title class_">double</span>[size];</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; values.length;i++) &#123;</span><br><span class="line">values[i] = i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> values;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>使用并行化数组操作初始化数组</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">double</span>[] parallelInitialize(<span class="type">int</span> size) &#123;</span><br><span class="line"><span class="type">double</span>[] values = <span class="keyword">new</span> <span class="title class_">double</span>[size];</span><br><span class="line">Arrays.parallelSetAll(values, i -&gt; i);</span><br><span class="line"><span class="keyword">return</span> values;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 亚信实习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java8新特性 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>高级集合类和收集器</title>
      <link href="/2023/10/07/%E4%BA%9A%E4%BF%A1%E5%AE%9E%E4%B9%A0/%E7%AC%AC%E4%B8%80%E6%9C%88/day05-%E7%B1%BB%E5%BA%93/%E9%AB%98%E7%BA%A7%E9%9B%86%E5%90%88%E7%B1%BB%E5%92%8C%E6%94%B6%E9%9B%86%E5%99%A8/"/>
      <url>/2023/10/07/%E4%BA%9A%E4%BF%A1%E5%AE%9E%E4%B9%A0/%E7%AC%AC%E4%B8%80%E6%9C%88/day05-%E7%B1%BB%E5%BA%93/%E9%AB%98%E7%BA%A7%E9%9B%86%E5%90%88%E7%B1%BB%E5%92%8C%E6%94%B6%E9%9B%86%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/># 方法引用<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">artist -&gt; artist.getName()</span><br></pre></td></tr></table></figure><p>简写语法 –&gt;</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Artist::getName</span><br></pre></td></tr></table></figure><blockquote><p>标准语法为 Classname::methodName。需要注意的是，虽然这是一个方法，但不需要在后面 加括号，因为这里并不调用该方法。我们只是提供了和 Lambda 表达式等价的一种结构， 在需要时才会调用。凡是使用 Lambda 表达式的地方，就可以使用方法引用。</p></blockquote><p>构造函数也有同样的缩写形式，如果你想使用 Lambda 表达式创建一个 Artist 对象，可能 会写出如下代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(name, nationality) -&gt; <span class="keyword">new</span> <span class="title class_">Artist</span>(name, nationality)</span><br></pre></td></tr></table></figure><p>使用方法引用，上述代码可写为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Artist::<span class="keyword">new</span></span><br></pre></td></tr></table></figure><p>还可以用这种方式创建数组，下面的代码创建了一个字符串型的数组：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String[]::<span class="keyword">new</span></span><br></pre></td></tr></table></figure><h1 id="元素顺序"><a href="#元素顺序" class="headerlink" title="元素顺序"></a>元素顺序</h1><p>在一个有序集合中创建一个流时，流中的元素就按出现顺序排列，因此，例 5-1 中的代码 总是可以通过。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; numbers = asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>);</span><br><span class="line">List&lt;Integer&gt; sameOrder = numbers.stream()</span><br><span class="line">.collect(toList());</span><br><span class="line">assertEquals(numbers, sameOrder);</span><br></pre></td></tr></table></figure><p>如果集合本身就是无序的，由此生成的流也是无序的。HashSet 就是一种无序的集合，因 此不能保证以下的程序每次都通过。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Set&lt;Integer&gt; numbers = new HashSet&lt;&gt;(asList(4, 3, 2, 1));</span><br><span class="line">List&lt;Integer&gt; sameOrder = numbers.stream()</span><br><span class="line">.collect(toList());</span><br><span class="line">// 该断言有时会失败</span><br><span class="line">assertEquals(asList(4, 3, 2, 1), sameOrder);</span><br></pre></td></tr></table></figure><p>流的目的不仅是在集合类之间做转换，而且同时提供了一组处理数据的通用操作。有些集 合本身是无序的，但这些操作有时会产生顺序</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Set&lt;Integer&gt; numbers = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;(asList(<span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>));</span><br><span class="line">List&lt;Integer&gt; sameOrder = numbers.stream()</span><br><span class="line">.sorted()</span><br><span class="line">.collect(toList());</span><br><span class="line">assertEquals(asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>), sameOrder);</span><br></pre></td></tr></table></figure><p>一些中间操作会产生顺序，比如对值做映射时，映射后的值是有序的，这种顺序就会保留 下来。如果进来的流是无序的，出去的流也是无序的。看一下例 5-4 所示代码，我们只能 断言 HashSet 中含有某元素，但对其顺序不能作出任何假设，因为 HashSet 是无序的，使 用了映射操作后，得到的集合仍然是无序的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; numbers = asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>);</span><br><span class="line">List&lt;Integer&gt; stillOrdered = numbers.stream()</span><br><span class="line">.map(x -&gt; x + <span class="number">1</span>)</span><br><span class="line">.collect(toList());</span><br><span class="line"><span class="comment">// 顺序得到了保留</span></span><br><span class="line">assertEquals(asList(<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>), stillOrdered);</span><br><span class="line">Set&lt;Integer&gt; unordered = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;(numbers);</span><br><span class="line">List&lt;Integer&gt; stillUnordered = unordered.stream()</span><br><span class="line">.map(x -&gt; x + <span class="number">1</span>)</span><br><span class="line">.collect(toList());</span><br><span class="line"><span class="comment">// 顺序得不到保证</span></span><br><span class="line">assertThat(stillUnordered, hasItem(<span class="number">2</span>));</span><br><span class="line">assertThat(stillUnordered, hasItem(<span class="number">3</span>));</span><br><span class="line">assertThat(stillUnordered, hasItem(<span class="number">4</span>));</span><br><span class="line">assertThat(stillUnordered, hasItem(<span class="number">5</span>));</span><br></pre></td></tr></table></figure><h1 id="使用收集器"><a href="#使用收集器" class="headerlink" title="使用收集器"></a>使用收集器</h1><h2 id="转换成其他集合"><a href="#转换成其他集合" class="headerlink" title="转换成其他集合"></a>转换成其他集合</h2><blockquote><p>使用 toCollection，用定制的集合收集元素</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">stream.collect(toCollection(TreeSet::<span class="keyword">new</span>));</span><br></pre></td></tr></table></figure><h2 id="转换成值"><a href="#转换成值" class="headerlink" title="转换成值"></a>转换成值</h2><blockquote><p>还可以利用收集器让流生成一个值。maxBy 和 minBy 允许用户按某种特定的顺序生成一个 值。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Optional&lt;Artist&gt; <span class="title function_">biggestGroup</span><span class="params">(Stream&lt;Artist&gt; artists)</span> &#123;</span><br><span class="line">Function&lt;Artist,Long&gt; getCount = artist -&gt; artist.getMembers().count();</span><br><span class="line"><span class="keyword">return</span> artists.collect(maxBy(comparing(getCount)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>还有些收集器实现了一些常用的数值运算。让我们通过一个计算专辑曲目平均数的例子来 看看</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">double</span> <span class="title function_">averageNumberOfTracks</span><span class="params">(List&lt;Album&gt; albums)</span> &#123;</span><br><span class="line"><span class="keyword">return</span> albums.stream()</span><br><span class="line">.collect(averagingInt(album -&gt; album.getTrackList().size()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="数据分块"><a href="#数据分块" class="headerlink" title="数据分块"></a>数据分块</h2><p>另外一个常用的流操作是将其分解成两个集合。假设有一个艺术家组成的流，你可能希望 将其分成两个部分，一部分是独唱歌手，另一部分是由多人组成的乐队。可以使用两次过 滤操作，分别过滤出上述两种艺术家</p><h3 id="partitioningBy-收集器"><a href="#partitioningBy-收集器" class="headerlink" title="partitioningBy 收集器"></a>partitioningBy 收集器</h3><p>使用它，我们就可以将乐队（有多个成员）和独唱歌手分开了。在本例中，分块函数指明 艺术家是否为独唱歌手。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Map&lt;Boolean, List&lt;Artist&gt;&gt; <span class="title function_">bandsAndSolo</span><span class="params">(Stream&lt;Artist&gt; artists)</span> &#123;</span><br><span class="line"><span class="keyword">return</span> artists.collect(partitioningBy(artist -&gt; artist.isSolo()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也可以使用方法引用代替 Lambda 表达式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Map&lt;Boolean, List&lt;Artist&gt;&gt; <span class="title function_">bandsAndSoloRef</span><span class="params">(Stream&lt;Artist&gt; artists)</span> &#123;</span><br><span class="line"><span class="keyword">return</span> artists.collect(partitioningBy(Artist::isSolo));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="数据分组"><a href="#数据分组" class="headerlink" title="数据分组"></a>数据分组</h3><p>数据分组是一种更自然的分割数据操作，与将数据分成 ture 和 false 两部分不同，可以使 用任意值对数据分组。比如现在有一个由专辑组成的流，可以按<strong>专辑当中的主唱对专辑分 组</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Map&lt;Artist, List&lt;Album&gt;&gt; <span class="title function_">albumsByArtist</span><span class="params">(Stream&lt;Album&gt; albums)</span> &#123;</span><br><span class="line"><span class="keyword">return</span> albums.collect(groupingBy(album -&gt; album.getMainMusician()));</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><p>使用 for 循环格式化艺术家姓名</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">StringBuilder</span> <span class="variable">builder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(<span class="string">&quot;[&quot;</span>);</span><br><span class="line"><span class="keyword">for</span> (Artist artist : artists) &#123;</span><br><span class="line"><span class="keyword">if</span> (builder.length() &gt; <span class="number">1</span>)</span><br><span class="line">builder.append(<span class="string">&quot;, &quot;</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> artist.getName();</span><br><span class="line">builder.append(name);</span><br><span class="line">&#125;</span><br><span class="line">builder.append(<span class="string">&quot;]&quot;</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> builder.toString();</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>使用流和收集器格式化艺术家姓名</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span></span><br><span class="line">artists.stream()</span><br><span class="line">.map(Artist::getName)</span><br><span class="line">.collect(Collectors.joining(<span class="string">&quot;, &quot;</span>, <span class="string">&quot;[&quot;</span>, <span class="string">&quot;]&quot;</span>));</span><br></pre></td></tr></table></figure><blockquote><p>‘joining()’ 是一个属于 ‘Collectors’ 类的方法，用于将流中的元素连接起来。在你的代码中，’Collectors.joining(“, “, “[“, “]”)’ 的含义如下：</p><ul><li>‘, ‘ 是连接每个元素的字符串。</li><li>‘[‘ 是前缀，意味着在所有艺术家名字连接的字符串之前会添加这个前缀。</li><li>‘]’ 是后缀，意味着在所有艺术家名字连接的字符串之后会添加这个后缀。</li></ul></blockquote><h3 id="组合收集器"><a href="#组合收集器" class="headerlink" title="组合收集器"></a>组合收集器</h3><blockquote><p>计算每个艺术家专辑数的简单方式</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;Artist, List&lt;Album&gt;&gt; albumsByArtist</span><br><span class="line">= albums.collect(groupingBy(album -&gt; album.getMainMusician()));</span><br><span class="line">Map&lt;Artist, Integer&gt; numberOfAlbums = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"><span class="keyword">for</span>(Entry&lt;Artist, List&lt;Album&gt;&gt; entry : albumsByArtist.entrySet()) &#123;</span><br><span class="line">numberOfAlbums.put(entry.getKey(), entry.getValue().size());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>这里实际上需要另外一个收集器，告诉 groupingBy 不用为每一个艺术家生成一个专辑 列表，只需要对专辑计数就可以了。幸好，核心类库已经提供了一个这样的收集器： counting。使用它，可将上述代码重写为以下的样子。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Map&lt;Artist, Long&gt; <span class="title function_">numberOfAlbums</span><span class="params">(Stream&lt;Album&gt; albums)</span> &#123;</span><br><span class="line"><span class="keyword">return</span> albums.collect(groupingBy(album -&gt; album.getMainMusician(),</span><br><span class="line">counting()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>这种方式看起来简单，但却有点杂乱无章。这段代码也是命令式的代码，不能自动适应并 行化操作。 这里实际上需要另外一个收集器，告诉 groupingBy 不用为每一个艺术家生成一个专辑 列表，只需要对专辑计数就可以了。幸好，核心类库已经提供了一个这样的收集器： counting。使用它，可将上述代码重写为例 5-14 所示的样子。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Map&lt;Artist, Long&gt; <span class="title function_">numberOfAlbums</span><span class="params">(Stream&lt;Album&gt; albums)</span> &#123;</span><br><span class="line"><span class="keyword">return</span> albums.collect(groupingBy(album -&gt; album.getMainMusician(),</span><br><span class="line">counting()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>使用简单方式求每个艺术家的专辑名</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Map&lt;Artist, List&lt;String&gt;&gt; <span class="title function_">nameOfAlbumsDumb</span><span class="params">(Stream&lt;Album&gt; albums)</span> &#123;</span><br><span class="line">Map&lt;Artist, List&lt;Album&gt;&gt; albumsByArtist =</span><br><span class="line">albums.collect(groupingBy(album -&gt;album.getMainMusician()));</span><br><span class="line">Map&lt;Artist, List&lt;String&gt;&gt; nameOfAlbums = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"><span class="keyword">for</span>(Entry&lt;Artist, List&lt;Album&gt;&gt; entry : albumsByArtist.entrySet()) &#123;</span><br><span class="line">nameOfAlbums.put(entry.getKey(), entry.getValue()</span><br><span class="line">.stream()</span><br><span class="line">.map(Album::getName)</span><br><span class="line">.collect(toList()));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> nameOfAlbums;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>使用收集器求每个艺术家的专辑名</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Map&lt;Artist, List&lt;String&gt;&gt; <span class="title function_">nameOfAlbums</span><span class="params">(Stream&lt;Album&gt; albums)</span> &#123;</span><br><span class="line"><span class="keyword">return</span> albums.collect(groupingBy(Album::getMainMusician,</span><br><span class="line">mapping(Album::getName, toList())));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="computeIfAbsent"><a href="#computeIfAbsent" class="headerlink" title="computeIfAbsent"></a>computeIfAbsent</h3><p>使用显示判断空值的方式缓存</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Artist <span class="title function_">getArtist</span><span class="params">(String name)</span> &#123;</span><br><span class="line"><span class="type">Artist</span> <span class="variable">artist</span> <span class="operator">=</span> artistCache.get(name);</span><br><span class="line"><span class="keyword">if</span> (artist == <span class="literal">null</span>) &#123;</span><br><span class="line">artist = readArtistFromDB(name);</span><br><span class="line">artistCache.put(name, artist);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> artist;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用 computeIfAbsent 缓存</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Artist <span class="title function_">getArtist</span><span class="params">(String name)</span> &#123;</span><br><span class="line"><span class="keyword">return</span> artistCache.computeIfAbsent(name, <span class="built_in">this</span>::readArtistFromDB);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 亚信实习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java8新特性 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>类库2</title>
      <link href="/2023/10/07/%E4%BA%9A%E4%BF%A1%E5%AE%9E%E4%B9%A0/%E7%AC%AC%E4%B8%80%E6%9C%88/day05-%E7%B1%BB%E5%BA%93/%E7%B1%BB%E5%BA%93/"/>
      <url>/2023/10/07/%E4%BA%9A%E4%BF%A1%E5%AE%9E%E4%B9%A0/%E7%AC%AC%E4%B8%80%E6%9C%88/day05-%E7%B1%BB%E5%BA%93/%E7%B1%BB%E5%BA%93/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/>@FunctionalInterface<p>每个用作函数接口的接口都应该添加这个注释。</p><p>该注释会强制 javac 检查一个接口是否符合函数接口的标准。如果该注释添加给一个枚举 类型、类或另一个注释，或者接口包含不止一个抽象方法，javac 就会报错。重构代码时， 使用它能很容易发现问题。</p><p>类中重写的方法优先级高于接口中定义的默认方法</p><h3 id="三定律"><a href="#三定律" class="headerlink" title="三定律"></a>三定律</h3><p>如果对默认方法的工作原理，特别是在多重继承下的行为还没有把握，如下三条简单的定 律可以帮助大家。</p><ol><li><p>类胜于接口。如果在继承链中有方法体或抽象的方法声明，那么就可以忽略接口中定义 的方法。 </p></li><li><p>子类胜于父类。如果一个接口继承了另一个接口，且两个接口都定义了一个默认方法， 那么子类中定义的方法胜出。 </p></li><li><p>没有规则三。</p></li><li><p>如果上面两条规则不适用，子类要么需要实现该方法，要么将该方法声明 为抽象方法。 其中第一条规则是为了让代码向后兼容。</p></li></ol><h3 id="Optional"><a href="#Optional" class="headerlink" title="Optional"></a>Optional</h3><blockquote><p>创建某个值的 Optional 对象</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Optional</span> <span class="variable">a</span> <span class="operator">=</span> Optional.of(<span class="string">&quot;a&quot;</span>); </span><br><span class="line"></span><br><span class="line">assertEquals(<span class="string">&quot;a&quot;</span>, a.get());</span><br></pre></td></tr></table></figure><h4 id="使用-orElse-和-orElseGet-方法"><a href="#使用-orElse-和-orElseGet-方法" class="headerlink" title="使用 orElse 和 orElseGet 方法"></a>使用 orElse 和 orElseGet 方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">assertEquals(<span class="string">&quot;b&quot;</span>, emptyOptional.orElse(<span class="string">&quot;b&quot;</span>));</span><br><span class="line">assertEquals(<span class="string">&quot;c&quot;</span>, emptyOptional.orElseGet(() -&gt; <span class="string">&quot;c&quot;</span>));</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 亚信实习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java8新特性 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>类库1</title>
      <link href="/2023/09/29/%E4%BA%9A%E4%BF%A1%E5%AE%9E%E4%B9%A0/%E7%AC%AC%E4%B8%80%E6%9C%88/day04-streamAPI/%E7%B1%BB%E5%BA%93/"/>
      <url>/2023/09/29/%E4%BA%9A%E4%BF%A1%E5%AE%9E%E4%B9%A0/%E7%AC%AC%E4%B8%80%E6%9C%88/day04-streamAPI/%E7%B1%BB%E5%BA%93/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/># 基本类型<p> Java 8 中为了减小性能开销，Stream 类的某些方法对基本类型和装箱类型做了区分。</p><p>在 Java 8 中，仅对整型、 长整型和双浮点型做了特殊处理，因为它们在数值计算中用得最多，特殊处理后的系统性 能提升效果最明显。</p><p><img src="https://gitee.com/Button_mkns/picgo/raw/master/img/%E7%B1%BB%E5%BA%9301" alt="image-20230928161756146"></p><p>对基本类型做特殊处理的方法在命名上有明确的规范。如果方法返回类型为基本类型，则 在基本类型前加 To，如图 4-1 中的 ToLongFunction。如果参数是基本类型，则不加前缀只 需类型名即可，如图 4-2 中的 LongFunction。如果高阶函数使用基本类型，则在操作后加 后缀 To 再加基本类型，如 mapToLong。</p><p><img src="https://gitee.com/Button_mkns/picgo/raw/master/img/%E7%B1%BB%E5%BA%9302" alt="image-20230928161937889"></p><p>这些基本类型都有与之对应的 Stream，以基本类型名为前缀，如 LongStream。事实上， mapToLong 方法返回的不是一个一般的 Stream，而是一个特殊处理的 Stream。在这个特 殊的 Stream 中，map 方法的实现方式也不同，它接受一个 LongUnaryOperator 函数，将 一个长整型值映射成另一个长整型值，如图 4-3 所示。通过一些高阶函数装箱方法，如 mapToObj，也可以从一个基本类型的 Stream 得到一个装箱后的 Stream，如 Stream。</p><p><img src="https://gitee.com/Button_mkns/picgo/raw/master/img/%E7%B1%BB%E5%BA%9303" alt="image-20230928162340555"></p><h2 id="使用-summaryStatistics-方法统计曲目长度"><a href="#使用-summaryStatistics-方法统计曲目长度" class="headerlink" title="使用 summaryStatistics 方法统计曲目长度"></a>使用 summaryStatistics 方法统计曲目长度</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">printTrackLengthStatistics</span><span class="params">(Album album)</span> &#123;</span><br><span class="line"><span class="type">IntSummaryStatistics</span> <span class="variable">trackLengthStats</span></span><br><span class="line"><span class="operator">=</span> album.getTracks()</span><br><span class="line">.mapToInt(track -&gt; track.getLength())</span><br><span class="line">.summaryStatistics();</span><br><span class="line">System.out.printf(<span class="string">&quot;Max: %d, Min: %d, Ave: %f, Sum: %d&quot;</span>,</span><br><span class="line">trackLengthStats.getMax(),</span><br><span class="line">trackLengthStats.getMin(),</span><br><span class="line">trackLengthStats.getAverage(),</span><br><span class="line">trackLengthStats.getSum());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>无需手动计算这些信息，这里使用对基 本类型进行特殊处理的方法 mapToInt，将每首曲目映射为曲目长度。<strong>因为该方法返回一个 IntStream 对象，它包含一个 summaryStatistics 方法，这个方法能计算出各种各样的统计 值，如 IntStream 对象内所有元素中的最小值、最大值、平均值以及数值总和。</strong> 这些统计值在所有特殊处理的 Stream，如 DoubleStream、LongStream 中都可以得出。如无 需全部的统计值，也可分别调用 min、max、average 或 sum 方法获得单个的统计值，同样， 三种基本类型对应的特殊 Stream 也都包含这些方法。</p>]]></content>
      
      
      <categories>
          
          <category> 亚信实习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java8新特性 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java8新特性的继续学习</title>
      <link href="/2023/09/28/%E4%BA%9A%E4%BF%A1%E5%AE%9E%E4%B9%A0/%E7%AC%AC%E4%B8%80%E6%9C%88/day04-streamAPI/java8%E6%96%B0%E7%89%B9%E6%80%A7%E7%9A%84%E7%BB%A7%E7%BB%AD%E5%AD%A6%E4%B9%A0/"/>
      <url>/2023/09/28/%E4%BA%9A%E4%BF%A1%E5%AE%9E%E4%B9%A0/%E7%AC%AC%E4%B8%80%E6%9C%88/day04-streamAPI/java8%E6%96%B0%E7%89%B9%E6%80%A7%E7%9A%84%E7%BB%A7%E7%BB%AD%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/># 高阶函数<p>高阶函数是指接受另外一个函 数作为参数，或返回一个函数的函数。高阶函数不难辨认：看函数签名就够了。如果函数 的参数列表里包含函数接口，或该函数返回一个函数接口，那么该函数就是高阶函数。</p><p><strong>map 是一个高阶函数</strong>，因为<strong>它的 mapper 参数是一个函数</strong>。事实上，本章介绍的 Stream 接口 中几乎所有的函数都是高阶函数。之前的排序例子中还用到了 comparing 函数，它接受一 个函数作为参数，获取相应的值，同时返回一个 Comparator。Comparator 可能会被误认为 是一个对象，但它有且只有一个抽象方法，所以实际上是一个函数接口。</p><h1 id="正确使用Lambda表达式"><a href="#正确使用Lambda表达式" class="headerlink" title="正确使用Lambda表达式"></a>正确使用Lambda表达式</h1><p>以下是一个有副作用的Lambda表达式的案例：这里将参数 event 保存至成员变量 lastEvent。给变量赋值也是一种副作用，而且更难察 觉。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> ActionEvent lastEvent; <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">registerHandler</span><span class="params">()</span> &#123; button.addActionListener((ActionEvent event) -&gt; &#123; <span class="built_in">this</span>.lastEvent = event;&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 亚信实习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java8新特性 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>简单学习了若伊</title>
      <link href="/2023/09/28/%E4%BA%9A%E4%BF%A1%E5%AE%9E%E4%B9%A0/%E7%AC%AC%E4%B8%80%E6%9C%88/day03-%E8%8B%A5%E4%BC%8A/%E8%8B%A5%E4%BC%8A/"/>
      <url>/2023/09/28/%E4%BA%9A%E4%BF%A1%E5%AE%9E%E4%B9%A0/%E7%AC%AC%E4%B8%80%E6%9C%88/day03-%E8%8B%A5%E4%BC%8A/%E8%8B%A5%E4%BC%8A/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/>今天简单学习了一下若伊<p>学习进度：登陆功能的实现</p>]]></content>
      
      
      <categories>
          
          <category> 亚信实习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 其他技术 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>流（后续）</title>
      <link href="/2023/09/28/%E4%BA%9A%E4%BF%A1%E5%AE%9E%E4%B9%A0/%E7%AC%AC%E4%B8%80%E6%9C%88/day04-streamAPI/StreamAPI/"/>
      <url>/2023/09/28/%E4%BA%9A%E4%BF%A1%E5%AE%9E%E4%B9%A0/%E7%AC%AC%E4%B8%80%E6%9C%88/day04-streamAPI/StreamAPI/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/>#### Stream流的中间方法<p><img src="https://gitee.com/Button_mkns/picgo/raw/master/img/image-20230928092607019.png" alt="image-20230928092607019"></p><h4 id="Stream流的终结方法"><a href="#Stream流的终结方法" class="headerlink" title="Stream流的终结方法"></a>Stream流的终结方法</h4><p><img src="https://gitee.com/Button_mkns/picgo/raw/master/img/image-20230928101404072.png" alt="image-20230928101404072"></p><h4 id="Stream流总结"><a href="#Stream流总结" class="headerlink" title="Stream流总结"></a>Stream流总结</h4><h5 id="1-Stream流的作用"><a href="#1-Stream流的作用" class="headerlink" title="1.Stream流的作用"></a>1.Stream流的作用</h5><p>​结合了Lambda表达式、简化合集、数组的操作</p><h5 id="2-Stream的使用步骤"><a href="#2-Stream的使用步骤" class="headerlink" title="2.Stream的使用步骤"></a>2.Stream的使用步骤</h5><ul><li>获取Stream流对象</li><li>使用中间方法处理数据</li><li>使用终结方法处理数据</li></ul><h5 id="3-如何获取到Stream流对象"><a href="#3-如何获取到Stream流对象" class="headerlink" title="3.如何获取到Stream流对象"></a>3.如何获取到Stream流对象</h5><ul><li>单列集合：Collection中的默认方法Stream</li><li>双列集合：不能直接获取</li><li>数组：Arrays工具类中的静态方法stream</li><li>一堆零散的数据：Stream接口中的静态方法of</li></ul><h5 id="4-常见的方法"><a href="#4-常见的方法" class="headerlink" title="4.常见的方法"></a>4.常见的方法</h5><blockquote><p>中间方法： filter（过滤）limit（获取前几个）skip（跳过前几个）distinct（去重）concat（合并）map（转换）</p><p>终结方法： forEach（遍历）count（统计个数）collect（收集）</p></blockquote><h4 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h4><p>&#96;&#96;</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Collections;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.stream.Collectors;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> button</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2023-09-28-10:26</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StreamExer1</span> &#123;</span><br><span class="line">    <span class="comment">/*定义一个集合，并添加一些整数1, 2, 3 , 4, 5,6, 7, 8,9 , 10</span></span><br><span class="line"><span class="comment">    过滤奇数，只留下偶数。</span></span><br><span class="line"><span class="comment">    并将结果保存起来*/</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//1.定义一个集合，并添加一些整数1, 2, 3 , 4, 5,6, 7, 8,9 , 10</span></span><br><span class="line">        ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">//2.添加整数</span></span><br><span class="line">        Collections.addAll(list, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>);</span><br><span class="line">        <span class="comment">//3.过滤奇数只留下整数</span></span><br><span class="line">        <span class="comment">//进行，如果是偶数返回true 保留</span></span><br><span class="line">        List&lt;Integer&gt; newlist = list.stream()</span><br><span class="line">                .filter(n -&gt; n % <span class="number">2</span> == <span class="number">0</span>)</span><br><span class="line">                .collect(Collectors.toList());</span><br><span class="line">        <span class="comment">//4.打印集合</span></span><br><span class="line">        System.out.println(newlist);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&#96;&#96;</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Collections;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">import</span> java.util.function.Function;</span><br><span class="line"><span class="keyword">import</span> java.util.stream.Collectors;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> button</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2023-09-28-10:37</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StreamExer2</span> &#123;</span><br><span class="line">    <span class="comment">/*练习: 创建一个ArrayList集合，并添加以下字符串，字符串中前面是姓名，后面是年龄创建一个ArrayList集合，</span></span><br><span class="line"><span class="comment">           &quot;zhangsan, 23&quot;</span></span><br><span class="line"><span class="comment">           &quot;lisi,24&quot;</span></span><br><span class="line"><span class="comment">           &quot;wangwu , 25&quot;</span></span><br><span class="line"><span class="comment">           保留年龄大于等于24岁的人，并将结果收集到Map集合中，姓名为键，年龄为值*/</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//1.创建ArrayList集合</span></span><br><span class="line">        ArrayList&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        Collections.addAll(list, <span class="string">&quot;zhangsan,23&quot;</span>,<span class="string">&quot;lisi,24&quot;</span>, <span class="string">&quot;wangwu,25&quot;</span>);</span><br><span class="line">        <span class="comment">//2.保留年龄大于等于24的</span></span><br><span class="line">        <span class="comment">/*list.stream().filter(s -&gt; Integer.parseInt(s.split(&quot;,&quot;)[1]) &gt;= 24).collect(Collectors.toMap(new Function&lt;String, String&gt;() &#123;</span></span><br><span class="line"><span class="comment">            @Override</span></span><br><span class="line"><span class="comment">            public String apply(String s) &#123;</span></span><br><span class="line"><span class="comment">                return s.split(&quot;,&quot;)[0];</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">        &#125;, new Function&lt;String, Integer&gt;() &#123;</span></span><br><span class="line"><span class="comment">            @Override</span></span><br><span class="line"><span class="comment">            public Integer apply(String s) &#123;</span></span><br><span class="line"><span class="comment">                return Integer.parseInt(s.split(&quot;,&quot;)[1]);</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">        &#125;));*/</span></span><br><span class="line">        Map&lt;String, Integer&gt; map = list.stream()</span><br><span class="line">                .filter(s -&gt; Integer.parseInt(s.split(<span class="string">&quot;,&quot;</span>)[<span class="number">1</span>]) &gt;= <span class="number">24</span>)</span><br><span class="line">                .collect(Collectors.toMap(</span><br><span class="line">                        s -&gt; s.split(<span class="string">&quot;,&quot;</span>)[<span class="number">0</span>],</span><br><span class="line">                        s -&gt; Integer.parseInt(s.split(<span class="string">&quot;,&quot;</span>)[<span class="number">1</span>])));</span><br><span class="line">        System.out.println(map);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&#96;&#96;</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Collections;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.function.Function;</span><br><span class="line"><span class="keyword">import</span> java.util.stream.Collector;</span><br><span class="line"><span class="keyword">import</span> java.util.stream.Collectors;</span><br><span class="line"><span class="keyword">import</span> java.util.stream.Stream;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> button</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2023-09-28-10:58</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StreamExer3</span> &#123;</span><br><span class="line">    <span class="comment">/*现在有两个ArrayList集合，分别存储6名男演员的名字和年龄以及6名女演员的名字和年龄。姓名和年龄中间用逗号隔开。比如: 张三,23</span></span><br><span class="line"><span class="comment">    要求完成如下的操作:</span></span><br><span class="line"><span class="comment">    1，男演员只要名字为3个字的前两人</span></span><br><span class="line"><span class="comment">    2，女演员只要姓杨的，并且不要第一个</span></span><br><span class="line"><span class="comment">    3，把过滤后的男演员姓名和女演员姓名合并到一起</span></span><br><span class="line"><span class="comment">    4，将上一步的演员姓名封装成Actor对象。</span></span><br><span class="line"><span class="comment">    5，将所有的演员对象都保存到List集合中备注:演员类Actor，属性有: name，age</span></span><br><span class="line"><span class="comment">    男演员:&quot;蔡坤坤,24&quot;&quot;叶剿威,23&quot;，&quot;刘不甜,22&quot;，&quot;吴签,24&quot;，&quot;谷嘉,38&quot;，&quot;肖梁梁,27&quot;</span></span><br><span class="line"><span class="comment">    女演员:&quot;赵小颖,35”，&quot;杨颖,36&quot;，&quot;高元元,43&quot;，&quot;张天天,31&quot;，&quot;刘诗,35&quot;，&quot;杨小幂,33&quot;</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//1.建立两个list并且添加数据</span></span><br><span class="line">        ArrayList&lt;String&gt; manlist = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        ArrayList&lt;String&gt; womenlist = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        Collections.addAll(manlist, <span class="string">&quot;蔡坤坤,24&quot;</span>, <span class="string">&quot;叶剿威,23&quot;</span>, <span class="string">&quot;刘不甜,22&quot;</span>, <span class="string">&quot;吴签,24&quot;</span>, <span class="string">&quot;谷嘉,38&quot;</span>, <span class="string">&quot;肖梁梁,27&quot;</span>);</span><br><span class="line">        Collections.addAll(womenlist,<span class="string">&quot;赵小颖,35&quot;</span>,<span class="string">&quot;杨颖,36&quot;</span>,<span class="string">&quot;高元元,43&quot;</span>,<span class="string">&quot;张天天,31&quot;</span>,<span class="string">&quot;刘诗,35&quot;</span>,<span class="string">&quot;杨小幂,33&quot;</span>);</span><br><span class="line">        <span class="comment">//男演员只要名字为三给字的前两个人</span></span><br><span class="line">        Stream&lt;String&gt; stream1 = manlist.stream()</span><br><span class="line">                .filter(s -&gt; s.split(<span class="string">&quot;,&quot;</span>)[<span class="number">0</span>].length() == <span class="number">3</span>)</span><br><span class="line">                .limit(<span class="number">2</span>);</span><br><span class="line">        <span class="comment">//4.女演员只要姓杨的，并且不要第一个</span></span><br><span class="line">        Stream&lt;String&gt; stream2 = womenlist.stream().filter(s -&gt; s.split(<span class="string">&quot;,&quot;</span>)[<span class="number">0</span>].startsWith(<span class="string">&quot;杨&quot;</span>)).skip(<span class="number">1</span>);</span><br><span class="line">        <span class="comment">//5.把过滤后的男演员姓名和女演员姓名合并到一起</span></span><br><span class="line">        <span class="comment">//6.，将上一步的演员姓名封装成Actor对象。</span></span><br><span class="line">        <span class="comment">/*Stream.concat(stream1,stream2).map(new Function&lt;String, Actor&gt;() &#123;</span></span><br><span class="line"><span class="comment">            @Override</span></span><br><span class="line"><span class="comment">            public Actor apply(String s) &#123;</span></span><br><span class="line"><span class="comment">                String name = s.split(&quot;,&quot;)[0];</span></span><br><span class="line"><span class="comment">                int age = Integer.parseInt(s.split(&quot;,&quot;)[1]);</span></span><br><span class="line"><span class="comment">                Actor actor = new Actor(name, age);</span></span><br><span class="line"><span class="comment">                return actor;</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">        &#125;).forEach(s -&gt; System.out.println(s));*/</span></span><br><span class="line"></span><br><span class="line">        List&lt;Actor&gt; list = Stream.concat(stream1, stream2)</span><br><span class="line">                .map(s -&gt; <span class="keyword">new</span> <span class="title class_">Actor</span>(s.split(<span class="string">&quot;,&quot;</span>)[<span class="number">0</span>], Integer.parseInt(s.split(<span class="string">&quot;,&quot;</span>)[<span class="number">1</span>])))</span><br><span class="line">                .collect(Collectors.toList());</span><br><span class="line">        System.out.println(list);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注：</strong>可以在流式操作中省略<code>.stream()</code>方法。在Java 8及更高版本中，<code>.stream()</code>方法已经成为流式操作的默认方法，因此在调用<code>filter()</code>、<code>map()</code>和<code>collect()</code>等操作符时，可以直接省略<code>.stream()</code>方法。</p>]]></content>
      
      
      <categories>
          
          <category> 亚信实习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java8新特性 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Lambda 表达式</title>
      <link href="/2023/09/26/%E4%BA%9A%E4%BF%A1%E5%AE%9E%E4%B9%A0/%E7%AC%AC%E4%B8%80%E6%9C%88/day01-lambad%E8%A1%A8%E8%BE%BE%E5%BC%8F&amp;streamApi/Lambda%20%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
      <url>/2023/09/26/%E4%BA%9A%E4%BF%A1%E5%AE%9E%E4%B9%A0/%E7%AC%AC%E4%B8%80%E6%9C%88/day01-lambad%E8%A1%A8%E8%BE%BE%E5%BC%8F&amp;streamApi/Lambda%20%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/>### Lambda 表达式<p>示例</p><p><code>button.addActionListener(new ActionListener() &#123; public void actionPerformed(ActionEvent event) &#123; System.out.println(&quot;button clicked&quot;); &#125; &#125;);</code></p><p>使用lambda表达式</p><p><code>button.addActionListener(event -&gt; System.out.println(&quot;button clicked&quot;));</code></p><p>和传入一个实现某接口的对象不同，我们传入了一段代码块——<strong>一个没有名字的函数</strong>。 event 是参数名，和上面匿名内部类示例中的是同一个参数。-&gt; 将参数和 Lambda 表达式 的主体分开，而主体是用户点击按钮时会运行的一些代码。</p><h5 id="编写-Lambda-表达式的不同形式"><a href="#编写-Lambda-表达式的不同形式" class="headerlink" title="编写 Lambda 表达式的不同形式"></a>编写 Lambda 表达式的不同形式</h5><ol><li><p><code>Runnable noArguments = () -&gt; System.out.println(&quot;Hello World&quot;);</code> </p><blockquote><p>该 Lambda 表达式不包含参数，使用空括号 () 表示没有参数。该 Lambda 表达式 实现了 Runnable 接口，该接口也只有一个 run 方法，没有参数，且返回类型为 void。</p></blockquote></li><li><p><code>ActionListener oneArgument = event -&gt; System.out.println(&quot;button clicked&quot;);</code></p><blockquote><p>该Lambda 表达式包含且只包含一个参数，可省略参数的括号，这和例 2-2 中的 形式一样</p></blockquote></li><li><p><code>Runnable multiStatement = () -&gt; &#123;System.out.print(&quot;Hello&quot;); System.out.println(&quot; World&quot;); &#125;;</code></p></li><li><p><code>BinaryOperator add = (x, y) -&gt; x + y;</code></p><blockquote><p>Lambda 表达式也可以表示包含多个参数的方法，如➍所示。这时就有必要思考怎样去阅 读该 Lambda 表达式。这行代码并不是将两个数字相加，而是创建了一个函数，用来计算 两个数字相加的结果。变量 add 的类型是 BinaryOperator，它不是两个数字的和， 而是将两个数字相加的那行代码。</p></blockquote></li><li><p><code>BinaryOperator addExplicit = (Long x, Long y) -&gt; x + y;</code></p><blockquote><p>到目前为止，所有 Lambda 表达式中的参数类型都是由编译器推断得出的。这当然不错， 但有时最好也可以显式声明参数类型，此时就需要使用小括号将参数括起来，多个参数的 情况也是如此。如➎所示。</p></blockquote></li></ol><h5 id="目标类型"><a href="#目标类型" class="headerlink" title="目标类型"></a>目标类型</h5><p>目标类型是指 Lambda 表达式所在上下文环境的类型。比如，将 Lambda 表 达式赋值给一个局部变量，或传递给一个方法作为参数，局部变量或方法参 数的类型就是 Lambda 表达式的目标类型</p><blockquote><p><strong>例如</strong></p><p><code>final String[] array = &#123; &quot;hello&quot;, &quot;world&quot; &#125;</code></p></blockquote><h5 id="匿名内部类中使用-final-局部变量"><a href="#匿名内部类中使用-final-局部变量" class="headerlink" title="匿名内部类中使用 final 局部变量"></a>匿名内部类中使用 final 局部变量</h5><p><code>final String name = getUserName(); button.addActionListener(new ActionListener() &#123; public void actionPerformed(ActionEvent event) &#123; System.out.println(&quot;hi &quot; + name); &#125; &#125;);</code></p><h5 id="Lambda-表达式中引用既成事实上的-final-变量"><a href="#Lambda-表达式中引用既成事实上的-final-变量" class="headerlink" title="Lambda 表达式中引用既成事实上的 final 变量"></a>Lambda 表达式中引用既成事实上的 final 变量</h5><p><code>String name = getUserName(); button.addActionListener(event -&gt; System.out.println(&quot;hi &quot; + name));</code></p><h4 id="函数接口"><a href="#函数接口" class="headerlink" title="函数接口"></a>函数接口</h4><p>函数接口是<strong>只有一个抽象方法的接口</strong>，用作 Lambda 表达式的类型。</p><p>例如 <strong>ActionListener 接口：接受 ActionEvent 类型的参数，返回空</strong></p><p><code>public interface ActionListener extends EventListener &#123; public void actionPerformed(ActionEvent event); &#125;</code></p><p><img src="https://z1.ax1x.com/2023/10/11/piSZTG8.png" alt="piSZTG8.png">]</p><h4 id="类型推断"><a href="#类型推断" class="headerlink" title="类型推断"></a>类型推断</h4><blockquote><p><strong>使用菱形操作符，根据变量类型做推断</strong></p><p><code>Map oldWordCounts = new HashMap(); n Map diamondWordCounts = new HashMap&lt;&gt;();</code></p></blockquote><blockquote><p><strong>使用菱形操作符，根据方法签名做推断</strong></p><p><code>useHashmap(new HashMap&lt;&gt;());</code></p><p><code>private void useHashmap(Map values);</code></p></blockquote><h5 id="使用-Lambda-表达式检测一个-Integer-是否大于-5"><a href="#使用-Lambda-表达式检测一个-Integer-是否大于-5" class="headerlink" title="使用 Lambda 表达式检测一个 Integer 是否大于 5"></a>使用 Lambda 表达式检测一个 Integer 是否大于 5</h5><p><code>Predicate atLeast5 = x -&gt; x &gt; 5;</code></p><blockquote><p> Predicate 接口的源码，接受一个对象，返回一个布尔值</p><p> <code>public interface Predicate &#123; </code></p><p> ​<code>boolean test(T t); </code></p><p> ​<code>&#125;</code></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 亚信实习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java8新特性 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>git</title>
      <link href="/2023/09/25/%E4%BA%9A%E4%BF%A1%E5%AE%9E%E4%B9%A0/%E7%AC%AC%E4%B8%80%E6%9C%88/day02-git/Git%E6%95%99%E7%A8%8B/"/>
      <url>/2023/09/25/%E4%BA%9A%E4%BF%A1%E5%AE%9E%E4%B9%A0/%E7%AC%AC%E4%B8%80%E6%9C%88/day02-git/Git%E6%95%99%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/>## git基础<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># Git 基础操作和命令</span></span><br><span class="line"></span><br><span class="line"><span class="section">## 1. 安装 Git</span></span><br><span class="line"></span><br><span class="line">首先，你需要安装 Git。你可以从 Git 官网下载适合你操作系统的安装包，然后按照安装向导进行安装。</span><br><span class="line"></span><br><span class="line"><span class="section">## 2. 创建和初始化 Git 仓库</span></span><br><span class="line"></span><br><span class="line">使用以下命令在本地创建一个新的 Git 仓库：</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="code">```bash</span></span><br><span class="line"><span class="code">mkdir my_project</span></span><br><span class="line"><span class="code">cd my_project</span></span><br><span class="line"><span class="code">git init</span></span><br></pre></td></tr></table></figure><p>初始化后，你会在项目的根目录看到 <code>.git</code> 文件夹，这个文件夹是 Git 的仓库。</p><h2 id="3-添加文件到-Git-仓库"><a href="#3-添加文件到-Git-仓库" class="headerlink" title="3. 添加文件到 Git 仓库"></a>3. 添加文件到 Git 仓库</h2><p>你可以使用 <code>git add</code> 命令将文件添加到 Git 仓库。这个命令可以将文件添加到暂存区。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&quot;Hello, world!&quot;</span> &gt; readme.txt</span><br><span class="line">git add readme.txt</span><br></pre></td></tr></table></figure><p>如果你添加了多个文件，可以使用 <code>git add .</code> 将所有文件添加到暂存区。</p><h2 id="4-提交更改到远程仓库"><a href="#4-提交更改到远程仓库" class="headerlink" title="4. 提交更改到远程仓库"></a>4. 提交更改到远程仓库</h2><p>使用 <code>git commit</code> 命令将更改提交到远程仓库。这个命令会将暂存区的更改打包成一个新的提交对象，并记录下提交者的信息、提交时间、提交消息等信息。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git commit -m <span class="string">&quot;Initial commit&quot;</span></span><br></pre></td></tr></table></figure><p>你可以在 <code>-m</code> 后面的参数中输入你的提交消息。如果你想使用图形界面进行提交，可以使用 <code>-p</code> 参数。</p><h2 id="5-推送更改到远程仓库"><a href="#5-推送更改到远程仓库" class="headerlink" title="5. 推送更改到远程仓库"></a>5. 推送更改到远程仓库</h2><p>使用 <code>git push</code> 命令将你的更改推送到远程仓库。这个命令会将你的更改推送到远程仓库的 <code>master</code> 分支。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push origin master</span><br></pre></td></tr></table></figure><p>如果你想推送到其他分支，可以使用 <code>-u</code> 参数指定一个远程分支。例如，如果你想将更改推送到名为 <code>develop</code> 的分支，可以使用以下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push -u origin develop</span><br></pre></td></tr></table></figure><h2 id="6-查看更改和历史记录"><a href="#6-查看更改和历史记录" class="headerlink" title="6. 查看更改和历史记录"></a>6. 查看更改和历史记录</h2><p>使用 <code>git status</code> 命令可以查看当前工作区的更改和 Git 仓库的状态。使用 <code>git log</code> 命令可以查看提交历史记录。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git status</span><br><span class="line">git <span class="built_in">log</span> -p -5 --graph --all --decorate --oneline --graph --all --decorate --all --decorate --all --decorate --all --decorate --all --decorate --all --decorate --all --decorate --all --decorate --all --decorate --all --decorate --all --decorate --all --decorate --all --decorate --all --decorate --all --decorate --all --decorate --all --decorate --all --decorate --all --decorate --all --decorate --all --decorate --all --decorate --all --decorate --all --decorate --all --decorate --all --decorate --all --decorate --all --decorate --all --decorate --all --decorate --all --decorate --all --decorate -r -r -r -r -r -r -r -r -r -r -r -r -r -r -r -r -r -r -r -r -r -r -r -r -r -r -r -r -r -r -r -r -r -r -r -r -r -r -r -r -r -r -r -r -r -r -r -r -r -r -r -r -r -r -r -r -r -r -r -r -r -r -r -r -r -r -r -r -r -r -r -r -r -r -r -r -r -r -r -r -r -r -r -r -r -r -r -r -r -r -r -r -r -r -r -r -r -r -r -r -r -r -r</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 亚信实习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 其他技术 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>流</title>
      <link href="/2023/09/25/%E4%BA%9A%E4%BF%A1%E5%AE%9E%E4%B9%A0/%E7%AC%AC%E4%B8%80%E6%9C%88/day01-lambad%E8%A1%A8%E8%BE%BE%E5%BC%8F&amp;streamApi/%E6%B5%81/"/>
      <url>/2023/09/25/%E4%BA%9A%E4%BF%A1%E5%AE%9E%E4%B9%A0/%E7%AC%AC%E4%B8%80%E6%9C%88/day01-lambad%E8%A1%A8%E8%BE%BE%E5%BC%8F&amp;streamApi/%E6%B5%81/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/>### 常用的流操作<p><strong>1、 collect(toList())</strong></p><blockquote><p>collect(toList()) 方法由 Stream 里的值生成一个列表，是一个及早求值操作。</p></blockquote><p><strong>2、 map</strong></p><blockquote><p><strong>使用 for 循环将字符串转换为大写</strong></p></blockquote><p><code>List collected = new ArrayList&lt;&gt;(); </code></p><p><code>for (String string : asList(&quot;a&quot;, &quot;b&quot;, &quot;hello&quot;)) &#123; </code></p><p><code>String uppercaseString = string.toUpperCase(); </code></p><p><code>collected.add(uppercaseString); </code></p><p><code>&#125; </code></p><p><code>assertEquals(asList(&quot;A&quot;, &quot;B&quot;, &quot;HELLO&quot;), collected);</code></p><p><img src="https://z1.ax1x.com/2023/10/11/piSZ7RS.png" alt="piSZ7RS.png"></p><p>map操作</p><blockquote><p><strong>使用 map 操作将字符串转换为大写形式</strong></p></blockquote><p><code>List collected = Stream.of(&quot;a&quot;, &quot;b&quot;, &quot;hello&quot;)</code> </p><p>​<code>.map(string -&gt; string.toUpperCase())</code></p><p>​    <code>.collect(toList());</code></p><p><code>assertEquals(asList(&quot;A&quot;, &quot;B&quot;, &quot;HELLO&quot;), collected);</code></p><blockquote><p>传给 map  的 Lambda 表达式只接受一个 String 类型的参数，返回一个新的 String。参数 和返回值不必属于同一种类型，但是 Lambda 表达式必须是 Function 接口的一个实例（如 图 3-4 所示），Function 接口是只包含一个参数的普通函数接口。</p></blockquote><p><img src="https://z1.ax1x.com/2023/10/11/piSZoPf.png" alt="piSZoPf.png"></p><p><strong>3. filter</strong></p><blockquote><p>遍历数据并检查其中的元素时，可尝试使用 Stream 中提供的新方法 filter</p></blockquote><p><img src="https://z1.ax1x.com/2023/10/11/piSZ5IP.png" alt="piSZ5IP.png"></p><blockquote><p>使用循环遍历列表，使用条件语句做判断</p></blockquote><p><code>List beginningWithNumbers = new ArrayList&lt;&gt;();</code></p><p><code>for(String value : asList(&quot;a&quot;, &quot;1abc&quot;, &quot;abc1&quot;)) &#123;</code></p><p>​ <code>if (isDigit(value.charAt(0))) &#123;</code> </p><p>​<code>beginningWithNumbers.add(value);</code> </p><p>​<code>&#125;</code> </p><p><code>&#125;</code> </p><p><code>assertEquals(asList(&quot;1abc&quot;), beginningWithNumbers);</code></p><p><img src="https://z1.ax1x.com/2023/10/11/piSZ4at.png" alt="piSZ4at.png"></p><p><strong>4、flatMap</strong></p><blockquote><p>flatMap 方法可用 Stream 替换值，然后将多个 Stream 连接成一个 StreamflatMap 方法可用 Stream 替换值，然后将多个 Stream 连接成一个 Stream</p></blockquote><p><img src="https://z1.ax1x.com/2023/10/11/piSZqMQ.png" alt="piSZqMQ.png"></p><blockquote><p><strong>包含多个列表的 Stream</strong></p></blockquote><p><code>List together = Stream.of(asList(1, 2), asList(3, 4))</code> </p><p>​ <code>.flatMap(numbers -&gt; numbers.stream())</code> </p><p>​<code>.collect(toList());</code></p><p> <code>assertEquals(asList(1, 2, 3, 4), together);</code></p><p><strong>5、max和min</strong></p><blockquote><p><strong>使用 Stream 查找最短曲目</strong></p></blockquote><p><img src="https://z1.ax1x.com/2023/10/11/piSZHxg.png" alt="piSZHxg.png"></p><p><strong>6、通用模式</strong></p><blockquote><p>max 和 min 方法都属于更通用的一种编程模式。要看到这种编程模式，最简单的方法是使 用 for 循环重写例 3-13 中的代码。例 3-14 和例 3-13 的功能一样，都是查找专辑中的最短 曲目，但是使用了 for 循环。</p></blockquote><p><img src="https://z1.ax1x.com/2023/10/11/piSZOqs.png" alt="piSZOqs.png"></p><p><strong>7、整合操作</strong></p><p>第一个要解决的问题是，找出某张专辑上<strong>所有乐队的国籍</strong>。艺术家列表里既有个人，也有 乐队。利用一点领域知识，假定一般乐队名以定冠词 The 开头。当然这不是绝对的，但也 差不多。</p><p>需要注意的是，这个问题绝不是简单地调用几个 API 就足以解决。这既不是使用 map 将一 组值映射为另一组值，也不是过滤，更不是将 Stream 中的元素最终归约为一个值。首先， 可将这个问题分解为如下几个步骤。</p><ol><li>找出专辑上的所有表演者。</li><li>分辨出哪些表演者是乐队。</li><li>找出每个乐队的国籍。</li><li>将找出的国籍放入一个集合。</li></ol><p>现在，找出每一步对应的 Stream API 就相对容易了：</p><ol><li>Album 类有个 getMusicians 方法，该方法返回一个 Stream 对象，包含整张专辑中所有的 表演者；</li><li>使用 filter 方法对表演者进行过滤，只保留乐队；</li><li>使用 map 方法将乐队映射为其所属国家；</li><li>使用 collect(Collectors.toList()) 方法将国籍放入一个列表。</li></ol><p>最后，整合所有的操作，就得到如下代码：</p><h4 id="重构遗留代码"><a href="#重构遗留代码" class="headerlink" title="重构遗留代码"></a>重构遗留代码</h4><p><img src="https://z1.ax1x.com/2023/10/11/piSZjZn.png" alt="piSZjZn.png"></p>]]></content>
      
      
      <categories>
          
          <category> 亚信实习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java8新特性 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>时间偏移</title>
      <link href="/2023/06/16/%E7%BA%BD%E6%89%A3%E5%BF%83%E5%BE%97/%E6%97%B6%E9%97%B4%E5%81%8F%E7%A7%BB/"/>
      <url>/2023/06/16/%E7%BA%BD%E6%89%A3%E5%BF%83%E5%BE%97/%E6%97%B6%E9%97%B4%E5%81%8F%E7%A7%BB/</url>
      
        <content type="html"><![CDATA[<p>总是纠结过去 ?幻想未来 ?可能你的先天能力失控了!!!!</p><p>相信正在看这个视频的你 应该和曾经的我一样总是时不时的对自己说，啊！ 如果能够回到当时我当时应该怎么怎么样，如果我当时那样做了那么我现在的人生就变成了什么什么样子。又或者是常常畅想未来，把自己带入未来的自己然后提前感受未来会发生的事情，比如喜欢一个女生你都没约人家出来吃饭呢，你连孩子叫什么都想好了，深深沉迷在自己幻想的幸福当中不可自拔，然后你一整晚都睡不着，接下来的第二天你的精神状态变得很差，本来想好的约她出来吃饭也因为状态不好推迟了，未来的美好和现在的“不美好”形成了对比，然后一种深深的失落感向你迎面扑来，把你扑入深渊，你逐渐看不到希望，变得不自信，自我怀疑，最终这段感情还没开始就在自己的不断内耗中结束了。之后过了很长时间你还是偶尔会想起那个女生，你又会问自己如果当时我不那样，我勇敢一点会不会有不一样的结果？然后你又试图把自己带入曾经的自己试图改变过去，然后回过神来发现现实依旧如此，回到过去力挽狂澜的快感消失不见，留下的只剩对自己的内疚以及悔不当初的负面情绪。</p><p>如果你有过这种经历，那么你当时就处于一种异常的时间偏移状态，人类的是生活在三维空间的生物，在这个空间里时间是线性的不可逆也不可跨越。但是人类的思维是属于更高维度的，你不可以回到过去或者跳跃到未来但是你的思维可以。人类可以依靠思维的高维性来对过去进行总结，对未来进行预演以此来帮助处于当下的自己。这种特性是我们人类现在处于当前位置最强大的工具。我将这种能力称为时间偏移，时间偏移是有弹性的他可以向前或者向后震动，但是每一次震动都必定会回到中心也就是当下，但是当发生异常时，回弹速度变慢甚至是不回弹此，时我称这种状态为时间偏差状态。</p><p>凡是工具就有两面性就像最近有很多人对AI很是恐慌，害怕未来AI毁灭人类等等。但是这个AI他不也就是一个工具吗？使用的好了可以让我们的生活更加便利，让我们的工作更加效率，但是不合理使用也有可能变成武器，又或者是过于依赖AI让很多人放弃自我思考把一切问题都抛给AI来解决。</p><p>思维的高维性也是如此，对过去进行总结，让自己产生后悔情绪从而避免下次犯错本是正常的行为，但是很多人当把他的思维送往过去总结经验时，发生了突发状况。你的思维回去了然后在自己假象的现实中做到了自己之前想要做成但却没做成的事，你猜怎么样？他把自己假象的现实当成了现实，不想回到现在了。此刻就出现了我说的时间偏移然后由于没有自动回溯就造成了时间偏差。你人在当下的时间中受苦，但是你的思维在过去享受着你可望而不可得的美好事物，当下的你能开心吗？那肯定不开心啊？你开心我不开心怎么办？</p><p>有两种办法：</p><p>一、大家都不开心，你给我回到现实来把你总结的经验告诉我从而防止下一次在发生类似的事情。在下一次经历的类似事件中弥补过去的遗憾。</p><p>二、大家都开心，现实的你跟随思维完全沉浸在过去的虚拟中，把思维营造出的幸福当成现实，从而毫不费力的获得一种满足感和幸福感。但是人类是三维生物，总是要回到现实生活的，当你迫不得已，被生活强迫拉回现实的时候，虚拟的幸福和不如人意的现实一对比，你会产生更强烈的对现状的不满进而你会更加的沉迷在过去，一步步越陷越深，越来越自责内疚。到头来没有总结到多少经验反而把自己的生活搞得一团糟。</p><p>相信听我举例完这两条情况你应该已经知道应该选择哪一种解决方式了。在这两种办法中第一种是正常的时间偏移，而第二种就是发生了时间偏差。</p><p>同样思维也可以跳跃到未来，对未来进行预演列出可能存在的可能性，从而对当下进行调整，以达到自己想要前往的未来。当你的思维来到了未来看到了种种可能性之后，正常情况是会平安回到你的现实指导你走向最为光明的未来的。但是有正常情况就一定会有异常情况。</p><p>思维来到了你想要到达的未来，就如同回到过去一样你的思维也沉迷于这样一种成功的虚拟中。你的思维直接跳过了想要成功所必须经历的艰辛，直接获得了成功的果实，哇太爽了一点都不累。此刻思维把自己带入获得成功的自己提前体验过了那无与伦比的幸福感，但是同样最终还是会被现实拉回来，正所谓由俭入奢易，由奢入俭难。以自己的角度感受了成功之后的爽，也就不想再体验成功路上的艰辛了，因此你会一头钻进未来虚拟的幸福，逃避现实的苦难，但是往往你越是逃避越是偏离未来的幸福。</p><p>当你看着自己和自己追求的幸福渐行渐远的时候，你又会产生后悔情绪，你会回到过去总结问题所在，如果能看清自己过于沉迷未来还好，但是还有一种情况就是你又会回到刚才我所说的（你开心我也开心状态），就这样你既沉迷在过去又沉迷在未来，但是唯独看不清当下。</p><p>此时你就是处于一种失控的时间偏移状态，时间偏差了，在时间偏差状态下对你来说过去和未来都比当下重要你把大量的精力用于在过去和未来体验幸福。你逐渐处于一种浑浑噩噩的状态，对过去和未来越是沉迷对当下的真实感也就越弱。</p><p>那么你就要对你的时间进行校准了。</p><p>你要明白当下才是现实，至于过去，过去就过去了，过去的你不是现在的你，当你的思维回到过去的时候，要以一种旁观者的角度看待问题。以第三方视角进行回顾，不要把自己带入过去的自己。坚守本心寻找问题而不是想着改变过去，将注意力尽快拉回现实；同样对于未来也要以第三方视角进行查看，并且不要过于细化推演很久远的未来，因为我发现当我们在幻想并沉迷自己未来的成功时往往都伴随着细节的考量，比如你幻想未来和自己喜欢的女孩子一起吃饭，你过于细化了吃饭这件事，你看到了那个女孩子的表情，你听到了那个女孩子说的话。过于细化就意味着真实感的提高，同时也就让你更加容易沉迷在这样的一种虚妄当中。对于这种比较遥远的终极目标你可以试着把未来抽象化，比如还是刚在的那个场景，但是你没有以第一视角和她吃饭，而是仅仅听到了一个类似于旁白的声音 经过了这一路的艰苦谁谁谁和某某某终于在一起了 。</p><p>要养成时刻观察自己的习惯，时刻察觉自己此时此刻在做什么。让自己对于当下的真实感得到提升。从而把精力集中在当下，我们真正可以控制的时间只有当下，只有当下的努力才是有效的努力，只有当下的改变才是真正的改变。至于过去和未来都是为了指引我们更好的活在当下。</p><h3 id="共勉"><a href="#共勉" class="headerlink" title="共勉"></a>共勉</h3>]]></content>
      
      
      <categories>
          
          <category> 自我抽风 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随便说说 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
